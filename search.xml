<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Xchart 源码分析（1）</title>
    <url>/2014/12/22/%20Xchart%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%881/</url>
    <content><![CDATA[<p>学校课程需要找一份代码，来讲讲代码里面用了哪些设计模式- -！ 还是要java的。。。 于是上github上面翻代码，偶然翻到一个java的xchart图标库，感觉可能以后会用的到，而且代码不是很长，就直接拿过来用了。具体的链接地址如下：<a href="https://github.com/timmolter/XChart" title="https://github.com/timmolter/XChart">https://github.com/timmolter/XChart</a></p>
<p>先看文件夹结构：<br> <a href="http://images.cnitblog.com/blog/372495/201412/212006353907368.png"><img src="http://images.cnitblog.com/blog/372495/201412/212021296717659.png" alt="image" title="image"></a>           </p>
<p>一共有6个包，最后一个是用来测试的包，可以忽略不计，一共5个包，5个包的作用分别是</p>
<ul>
<li><p>com.xeiam.xchart:<br>主要是图表生成的代码以及一些图表的功能包括导出功能的代码，是给我们使用该jar包人调用的结构，表示的是一个图表整体的构造，包括Chart,ChartBuild,Series等类。<br><a href="http://images.cnitblog.com/blog/372495/201412/212021311244117.png"><img src="http://images.cnitblog.com/blog/372495/201412/212021319529230.png" alt="image" title="image"></a></p>
</li>
<li><p>com.xeiam.xchart.internal<br>这个package里面只有两个类，一个是package-info，我也不是很明白他的作用。。。就是写了一个license的地址。另一个类是Utils的类，提供了两个静态方法，一个求幂的，一个就是求差值的一半。</p>
</li>
</ul>
<span id="more"></span>

<ul>
<li><p>com.xeiam.xchart.internal.chartpart<br>这个包里面的东西，都是一些绘图的基本元素，全部是从chartpart中继承过来的，利用组合模式来进行绘制和构造，主要包括Axis,chartTitle,legend,plot等基本图表的元素。<br><a href="http://images.cnitblog.com/blog/372495/201412/212021324522145.png"><img src="http://images.cnitblog.com/blog/372495/201412/212021336403214.png" alt="image" title="image"></a></p>
</li>
<li><p>com.xeiam.xchart.internal.markers<br>这个包里面，主要是针对刻度的一些绘图，包括圆形，矩形，上下三角形，菱形等。<br><a href="http://images.cnitblog.com/blog/372495/201412/212021341246600.png"><img src="http://images.cnitblog.com/blog/372495/201412/212021350622214.png" alt="image" title="image"></a>          </p>
</li>
<li><p>com.xeiam.xchart.internal.style<br>这个类主要是针对图表的一系列的外观进行定义的包，给出了几个主题，以及对于线的一些类型外观的设置。<br><a href="http://images.cnitblog.com/blog/372495/201412/212021356089113.png"><img src="http://images.cnitblog.com/blog/372495/201412/212021364994442.png" alt="image" title="image"></a>            </p>
</li>
</ul>
<p>作为一个轻量级的图表库，xchart通过这几个包里面的类进行图像的构造，最终画出一个图形出来，不过目前只能支持有限的几种图表类型。</p>
]]></content>
      <categories>
        <category>SourceReading</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-命令模式</title>
    <url>/2014/09/03/%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>命令模式这个设计模式更像是对接口编程的一种应用，比如给小朋友穿衣服，但是不一样的衣服有不一样的穿法，裤子，衬衫，鞋，T恤都是不一样的，但是小朋友不知道怎么穿，只知道想穿什么，那么怎么办呢，小朋友会让他的妈妈帮他穿，这里面的“让妈妈帮忙”，就是给妈妈一个命令（虽然不是很恰当- -！），对小朋友而言，怎么穿他并不关心，反正只要有只要让妈妈穿就行了，所以我们只要定义一个穿的接口就行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Wear()</span><br><span class="line">&#123;</span><br><span class="line">    public void excute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后继承这个穿，有很多种执行方式，比如穿鞋，穿衬衫，穿裤子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class WearShoe implements Wear&#123;</span><br><span class="line">    public void excute()</span><br><span class="line">    &#123;</span><br><span class="line">        .....//穿鞋的动作    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class WearShirt implements Wear&#123;</span><br><span class="line">    public void excute()</span><br><span class="line">    &#123;</span><br><span class="line">        .....//穿衬衫的动作    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class WearPants implements Wear&#123;</span><br><span class="line">    public void excute()</span><br><span class="line">    &#123;</span><br><span class="line">        .....//穿裤子的动作    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>对于妈妈来说，只要知道小朋友要穿什么，帮他穿上就好了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Mom&#123;</span><br><span class="line">    Wear wear;</span><br><span class="line">    public setCommand(Wear wear)</span><br><span class="line">    &#123;</span><br><span class="line">        this.wear = wear;</span><br><span class="line">    &#125;</span><br><span class="line">    public void Do()</span><br><span class="line">    &#123;</span><br><span class="line">        wear.excute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小朋友要做的事就是告诉妈妈我想穿什么，让妈妈帮它穿好就行了，具体怎么穿，他才不管呢</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Child&#123;</span><br><span class="line">    public static void main()</span><br><span class="line">    &#123;</span><br><span class="line">        Mom mom=new Mom();</span><br><span class="line">        WearShoe wearShoe=new WearShoe();</span><br><span class="line">        WearPants wearPants=new WearPants();</span><br><span class="line">        mom.setCommand(wearShoe);</span><br><span class="line">        mom.excute();</span><br><span class="line">        mom.setCommand(wearPants);</span><br><span class="line">        mom.excute();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以可以看出命令模式其实就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">命令模式：将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象，命令模式也支持可撤销的操作</span><br></pre></td></tr></table></figure>

<p>其中可撤销的操作其实就是在接口中加入脱衣服的接口，这样子既可以帮小朋友穿衣服也可以帮他脱掉衣服：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Wear()</span><br><span class="line">&#123;</span><br><span class="line">    public void excute();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    public void undo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再实现接口的对象中实现它就可以了。</p>
<p>命令模式在多线程处理任务的时候非常有效，只要将命令封装的对象，放入任务队列中，不同的线程通过队列获取对象，直接执行对象的excute()方法就行，而不用管具体命令是怎么执行的。</p>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>AC 自动机</title>
    <url>/2014/07/07/AC%20%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<p>AC 自动机主要有3个步骤：</p>
<ol>
<li>构造trie树</li>
<li>在trie树的基础上，添加失败指针，其添加方法就是一句话：由父亲节点开始，沿着失败指针向上找，一直找到一个节点p的next[i]不为空或者到根节点，把当前节点的next[i]的失败指针指向p的next[i] </li>
<li>进行模式串的匹配</li>
</ol>
<p> hdu 2222 代码，可兼作模板： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* * Author: xtestw </span></span><br><span class="line"><span class="comment">	* Created Time: 2014/7/7 8:54:30 </span></span><br><span class="line"><span class="comment">	* File Name: 2222.cpp **/</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxint = <span class="number">-1u</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">string image;</span><br><span class="line">string strs[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *next[<span class="number">26</span>];</span><br><span class="line">    Node *fail;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="built_in">Node</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        fail = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memset</span>(next, <span class="literal">NULL</span>, <span class="built_in">sizeof</span>(next));</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; q[<span class="number">500010</span>];</span><br><span class="line">Node *root;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string str, Node *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *p = root;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, index;</span><br><span class="line">    <span class="keyword">while</span> (str[i])</span><br><span class="line">    &#123;</span><br><span class="line">        index = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next[index] == <span class="literal">NULL</span>)</span><br><span class="line">            p-&gt;next[index] = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        p = p-&gt;next[index];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildfail</span><span class="params">(Node *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    root-&gt;fail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> head, tail;</span><br><span class="line">    head = tail = <span class="number">0</span>;</span><br><span class="line">    q[head++] = root;</span><br><span class="line">    <span class="keyword">while</span> (head != tail)</span><br><span class="line">    &#123;</span><br><span class="line">        Node *tmp = q[tail++];</span><br><span class="line">        Node *p = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp-&gt;next[i] != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (tmp == root)</span><br><span class="line">                    tmp-&gt;next[i]-&gt;fail = root;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    p = tmp-&gt;fail;</span><br><span class="line">                    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (p-&gt;next[i] != <span class="literal">NULL</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            tmp-&gt;next[i]-&gt;fail = p-&gt;next[i];</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p = p-&gt;fail;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">                        tmp-&gt;next[i]-&gt;fail = root;</span><br><span class="line">                &#125;</span><br><span class="line">                q[head++] = tmp-&gt;next[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(Node *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, cnt = <span class="number">0</span>, index, len = image.<span class="built_in">size</span>();</span><br><span class="line">    Node *p = root;</span><br><span class="line">    <span class="keyword">while</span> (image[i])</span><br><span class="line">    &#123;</span><br><span class="line">        index = image[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next[index] == <span class="literal">NULL</span> &amp;&amp; p != root)</span><br><span class="line">            p = p-&gt;fail;</span><br><span class="line">        p = p-&gt;next[index];</span><br><span class="line">        p = (p == <span class="literal">NULL</span>) ? root : p;</span><br><span class="line">        Node *tmp = p;</span><br><span class="line">        <span class="keyword">while</span> (tmp != root &amp;&amp; tmp-&gt;count != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt += tmp-&gt;count;</span><br><span class="line">            tmp-&gt;count = <span class="number">-1</span>;</span><br><span class="line">            tmp = tmp-&gt;fail;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE freopen(<span class="string">&quot;f:/in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> ios::sync_with_stdio(0);</span></span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            cin &gt;&gt; strs[i];</span><br><span class="line">        cin &gt;&gt; image;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">insert</span>(strs[i], root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">buildfail</span>(root);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">query</span>(root) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>详细的参看：<a href="http://www.cppblog.com/mythit/archive/2009/04/21/80633.html">http://www.cppblog.com/mythit/archive/2009/04/21/80633.html</a></p>
]]></content>
      <categories>
        <category>ACMICPC</category>
      </categories>
  </entry>
  <entry>
    <title>Blink学习笔记</title>
    <url>/2021/02/28/Blink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Blink 其实是阿里内部基于 flink 改造的系统，学习 Blink 首先要学习 flink 相关的知识，先了解一下 flink 产生的背景和要解决的问题。</p>
<p>在大数据开始爆发的时代，mapreduce 作为初代的计算引擎，提供了分布式计算的核心思想，map&amp;reduce的分阶段处理。但是 map reduce 本质上还是批处理计算框架，随着业务发展，流式数据计算处理的需求越来越旺盛，storm 等应运而生，但是作为第一代流式计算框架，存在一些设计上的缺陷，包括 exactly once等语义的支持。而且批处理和流处理作为处理同一个业务逻辑的两套系统，需要维护两套代码，并不是很友好。而这个时候 spark也发展起来了，集批处理，流处理，SQL 功能，图计算，机器学习于一身，并且支持 SparkR 和 PySpark 来做科学计算。而同时支持流处理和批处理的计算引擎，只有2个选择，除了spark 便是 flink。</p>
<span id="more"></span>

<p>spark 批流统一处理的核心思想其实是用批来模拟流的能力，而flink则完全相反，使用流计算来模拟批计算。flink在捐赠给apache后定位的主流方向便是 Streaming， 区别于Storm,Spark Streaming以及其他流式计算引擎的是：它不仅是一个高吞吐、低延迟的计算引擎，同时还提供很多高级的功能。比如它提供了有状态的计算，支持状态管理，支持强一致性的数据语义以及支持 Event Time,WaterMark 对消息乱序的处理。</p>
<p>最后，回归到官网对它的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Apache Flink 是一个框架和分布式处理引擎，用于在无边界和有边界数据流上进行有状态的计算。Flink 能在所有常见集群环境中运行，并能以内存速度和任意规模进行计算。</span><br></pre></td></tr></table></figure>

<p>关于应用场景， 官方主要给了3类应用和相应的事例可以参看：</p>
<ul>
<li><a href="https://flink.apache.org/zh/usecases.html#eventDrivenApps">事件驱动型应用</a></li>
<li><a href="https://flink.apache.org/zh/usecases.html#analytics">数据分析应用</a></li>
<li><a href="https://flink.apache.org/zh/usecases.html#pipelines">数据管道应用</a></li>
</ul>
<h2 id="设计架构"><a href="#设计架构" class="headerlink" title="设计架构"></a>设计架构</h2><p><img src="/images/Blink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210218205017997.png" alt="image-20210218205017997"></p>
<p>Client 构建dataflow graph 已经数据流下放到 jobmanager 去调度 taskmanager 执行。Flink 运行时由2种进程组成，JobManager 和 TaskManager。</p>
<h4 id="JobManager"><a href="#JobManager" class="headerlink" title="JobManager"></a>JobManager</h4><p>JobManager  负责task的调度、失败处理、协调处理checkpoint等，主要由3个组件构成：</p>
<ul>
<li>ResourceManager：负责资源的申请、分配、回收(适配 YARN、Mesos、Kubernetes等)。管理TaskManager的Task Slots</li>
<li>Dispacher：提供REST接口，用于提交Flink应用程序执行，并且为每一个Task启动一个新的JobMaster，同时提供一个WebUI反应作业执行情况。</li>
<li>JobMaster: 负责管理单个<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.12/zh/concepts/glossary.html#logical-graph">JobGraph</a>的执行。Flink 集群中可以同时运行多个作业，每个作业都有自己的 JobMaster。JobMaster可以有多个，其中一个事leader 其他的为Standby。JobMaster的HA有2种实现方式：Zookeeper 和 Kubernetes。</li>
</ul>
<h4 id="TaskManager"><a href="#TaskManager" class="headerlink" title="TaskManager"></a>TaskManager</h4><p>TaskManager 执行作业流的task，并且缓存和交换数据流。 本质上是一个 JVM 进程，可以在单独的线程中执行一个或多个 subtask，为了控制TaskManager接受多个task，也就是所谓的task slots。</p>
<p>Task、Subtask、Slot 是 3 个不同层面的概念</p>
<p>slot是独立资源，如果一个taskmanager有3个slot，那么每个slot独立分配1/3内存。同时同一个taskmanager下的slot共享同一个JVM。同一个JVM的多个task共享TCP链接和心跳信息。</p>
<p>默认允许 SubTask 共享 slot， 即便是不同的task的subtask，只要是一个作业就可以。也就是说，一个slot可以持有整个作业的通道。</p>
<h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>Flink的执行会被提交到3种类型的集群执行，其主要的差异在于执行的生命周期和资源的隔离保证：</p>
<ul>
<li>Flink Session 集群<ul>
<li>生命周期：集群是长期运行的，可接受多个作业提交</li>
<li>资源隔离：多个作业共享集群资源，如果 TaskManager 或者 JobManager 出问题，会影响所有集群运行</li>
</ul>
</li>
<li>Flink Job 集群<ul>
<li>生命周期：Yarn或者k8s 为每个作业启动一个集群，作业结束，则集群结束</li>
<li>资源隔离：作业独占资源</li>
</ul>
</li>
<li>Flink Application 集群<ul>
<li>生命周期：专用的flink集群，运行不是通过作业提交的方式运行，而是以application的方式运行。</li>
<li>资源隔离： ResourceManager 和 Dispatcher 作用于单个的 Flink 应用程序，相比于 Flink Session 集群，它提供了更好的隔离。</li>
</ul>
</li>
</ul>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>Flink的四大基石：</p>
<ul>
<li>Checkpoint: 快照；高容错</li>
<li>State: 状态</li>
<li>Time: 通过WaterMark支持基于Event Time的时间窗口</li>
<li>Window: 窗口机制</li>
</ul>
<h4 id="Checkpoint"><a href="#Checkpoint" class="headerlink" title="Checkpoint"></a>Checkpoint</h4><p><img src="/images/Blink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210228143710944.png" alt="image-20210228143710944"></p>
<p>checkpoint是一种通过快找容错恢复的机制，这种机制保证实时程序运行的时候，即便出现异常，也可以自我恢复。 checkpoint 是flink系统自身的系统行为，用户无感知，只需要配置就可以了。</p>
<ul>
<li>checkpoint 的实现参考了 <a href="https://en.wikipedia.org/wiki/Chandy-Lamport_algorithm">Chandy-Lamport algorithm</a> 算法， 自己实现了一套异步barrier快照的算法，在数据流中设置屏障，记录屏障点的信息(比如kafka偏移量)以及每个算子的 state 的状态。 拥有2个输入流的Operators 会执行 Barrier 对齐，保证当前快照消费了输入流barrier之前的所有events。                                        </li>
<li>checkpoint的状态备份存储主要分为2类<ul>
<li>基于RocksDB内嵌k/v存储，将工作状态保存到磁盘上</li>
<li>基于堆的 state backend.<ul>
<li>FsStateBackend，将状态快照持久化到分布式文件系统中</li>
<li>MemoryStateBackend, 使用JobManager的堆保存状态</li>
</ul>
</li>
</ul>
</li>
<li>在流处理过程中，对结果的保障分为3种<ul>
<li>at most once (结果不会从快照中恢复)</li>
<li>at least once（没有任何丢失，但是会有冗余结果）<ul>
<li>souce 必须可以重放</li>
</ul>
</li>
<li>Exactly once （没有丢失，没有冗余）<ul>
<li>souce 必须可以重放</li>
<li>sinks 必须是事务性的</li>
</ul>
</li>
</ul>
</li>
<li>checkpoint 状态保留策略<ul>
<li>当程序取消时，删除checkpoint存储文件</li>
<li>当程序取消时，保存之前的checkpoint文件</li>
</ul>
</li>
<li>chekpoint 配置<ul>
<li><em>Exactly-once/at-least-once 模式配置</em></li>
<li><em>checkpoint 超时</em>： 如果执行时间超过配置，checkpoint操作会被丢弃</li>
<li><em>并发checkpoint的数目</em>： 默认为1</li>
<li><em>checkpoints之间的最小时间</em></li>
<li><em>externalized checkpoints</em>: 周期存储 checkpoint 到外部系统中</li>
<li><em>在 checkpoint 出错时使 task 失败或者继续进行 task</em></li>
<li><em>优先从 checkpoint 恢复</em>: 在有savepoint的情况下的选择 (checkpoint 恢复的更快)</li>
</ul>
</li>
</ul>
<h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><p><img src="/images/Blink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210228151711717.png" alt="image-20210228151711717"></p>
<p>有状态的计算是流处理框架要实现的重要功能，因为稍复杂的流处理场景都需要记录状态，主要用来作为中间状态来进行去重/对比/聚合/更新等操作。 而在flink中，一个算子会有多个子任务，状态是和子任务绑定的，有子任务创建和管理。对于状态的管理，flink作为计算框架，封装了一些实现，也包括状态的高效存储/checkpoint/savepoint持久化/计算资源扩缩容等等。</p>
<ul>
<li>针对不同的场景，会有状态的类型的划分<ul>
<li>托管状态(Managed State)，由flink帮忙存储、恢复和优化，支持一些常见数据结构，比如ValueState/ListState/MapState<ul>
<li>Keyed State<ul>
<li>Keyed State是<code>KeyedStream</code>上的状态。假如输入流按照id为Key进行了<code>keyBy</code>分组，形成一个<code>KeyedStream</code>，数据流中所有id为1的数据共享一个状态，可以访问和更新这个状态，以此类推，每个Key对应一个自己的状态。</li>
<li>Flink提供了几种现成的数据结构供我们使用，包括<code>ValueState</code>、<code>ListState</code>等</li>
</ul>
</li>
<li>Operator State<ul>
<li>Operator State可以用在所有算子上，每个算子子任务或者说每个算子实例共享一个状态，流入这个算子子任务的数据可以访问和更新这个状态。</li>
</ul>
</li>
</ul>
</li>
<li>原生状态(Raw State)，需要开发者自己管理, 只支持字节，需要自己序列化</li>
</ul>
</li>
<li>横向扩展问题</li>
</ul>
<h4 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h4><p>Flink 在流程序中支持不同的Time概念；</p>
<ul>
<li>Time 类型<ul>
<li>Processing Time, 事件被处理时机器的系统时间</li>
<li>Event Time, 事件发生的时间</li>
<li>Ingestion Time, 事件进入 Flink 的时间</li>
</ul>
</li>
<li>Watermark 机制<ul>
<li>处理数据乱序的问题。在 Flink 的窗口处理过程中，如果确定<strong>全部数据到达</strong>，就可以对 Window 的所有数据做窗口计算操作（如汇总、分组等），如果数据没有全部到达，则继续等待该窗口中的数据全部到达才开始处理</li>
<li><code>Watermark = 进入 Flink 的最大的事件时间（mxtEventTime）— 指定的延迟时间（t）</code></li>
</ul>
</li>
</ul>
<h4 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h4><p><img src="/images/Blink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210228161951552.png" alt="image-20210228161951552"></p>
<p>前文提过，flink中其实是通过流来模拟批处理的，而window就是实现的机制。window可以是时间驱动的，也可以是数据驱动的 ，几种不同的窗口还行，可以参看上图。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="https://flink.apache.org/">https://flink.apache.org/</a></li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.12/zh/learn-flink/fault_tolerance.html">https://ci.apache.org/projects/flink/flink-docs-release-1.12/zh/learn-flink/fault_tolerance.html</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1478656">https://cloud.tencent.com/developer/article/1478656</a></li>
<li><a href="https://mp.weixin.qq.com/s/AoSDPDKbTbjH9rviioK-5Q">https://mp.weixin.qq.com/s/AoSDPDKbTbjH9rviioK-5Q</a></li>
<li><a href="https://arxiv.org/abs/1506.08603">https://arxiv.org/abs/1506.08603</a></li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>DDD 领域建模笔记</title>
    <url>/2021/03/15/DDD-%E9%A2%86%E5%9F%9F%E5%BB%BA%E6%A8%A1/</url>
    <content><![CDATA[<h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><blockquote>
<p>战术设计(Tactic DDD): Entity, Value Object; Aggregate, Root Entity, Service, Domain Event; Factory, Repository<br>战略设计(Strategic DDD): Bounded Context, Context Map; Published Language, Shared Kernel, Open Host Service, Customer-Supplier, Conformist, Anti Corruption Layer (context relationship types)</p>
</blockquote>
<h5 id="Entity（实体）"><a href="#Entity（实体）" class="headerlink" title="Entity（实体）"></a>Entity（实体）</h5><ul>
<li>存在 2 点特征<ul>
<li>唯一标志：当一些对象不是由属性定义，而是由一个唯一标志定义的话，我们就可以认为它是一个实体。</li>
<li>连续性：对象的连续性体现在对象是有生命周期的。</li>
</ul>
</li>
<li>由上2点可以看出，实体并非一定是映射到我们现实世界的某个具体事物</li>
<li>生成实体唯一标识的 4 种方法<ul>
<li>用户提供一个或者多个初始唯一值作为输入时</li>
<li>程序内部通过某种算法自动生成身份标识，例如UUID、雪花ID等</li>
<li>程序依赖于持久化存储，比如数据库生成的自增主键</li>
<li>通过其他的限界上下文决定出的唯一标识，作为程序的输入。</li>
</ul>
</li>
<li>实体不变性<ul>
<li>一个实体维护了一个或者多个不变条件</li>
<li>不变条件主要是由聚合所关注</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h5 id="Value-Object（值对象）"><a href="#Value-Object（值对象）" class="headerlink" title="Value Object（值对象）"></a>Value Object（值对象）</h5><ul>
<li>当我们只关心一个模型元素的属性时，应把它归类为值对象。</li>
<li>它度量或者描述了领域中的一件东西。</li>
<li>它将不同的相关属性组合成了一个概念整体。</li>
<li>它可以和其他值对象进行相等性比较。</li>
<li>值对象应该是不可变的，不要为它分配任何标识，不要将它设计得跟实体一样复杂。</li>
<li>值对象应该具有无副作用性</li>
</ul>
<h5 id="Aggregate（聚合）-amp-Root-Entity（根对象）"><a href="#Aggregate（聚合）-amp-Root-Entity（根对象）" class="headerlink" title="Aggregate（聚合）&amp; Root Entity（根对象）"></a>Aggregate（聚合）&amp; Root Entity（根对象）</h5><ul>
<li>描述<ul>
<li>每个聚合都有一个根和一个边界，边界内定义了聚合的内部有什么。”根” 是聚合所包含的一个特定的实体。</li>
<li>外部对象可以引用根，但不能引用聚合内部的其他对象，聚合内的对象之间可以相互引用，除了根实体外，其他实体拥有本地标识。</li>
</ul>
</li>
<li>定义<ul>
<li>我们应该将实体和值对象分门别类的聚集到聚合当中，并定义聚合的边界。并通过根来控制边界内其他对象的所有访问。只允许外部对象保持对根的引用。对内部成员的临时引用可以被传递出去，但仅在一次操作中有效。</li>
</ul>
</li>
<li>不变性和一致性边界即是聚合的设计依据和精髓。<ul>
<li>这里的不变性指的是业务规则，该规则应该始终保持一致</li>
<li>一致性边界的意思是单个事务的修改范围。 原则上我们应该在一个事务里只修改一个聚合。</li>
</ul>
</li>
<li>聚合的作用<ul>
<li>为了维护对象生命周期内的完整性</li>
<li>通过定义清晰的所属关系和边界，在这个边界中的模型元素在生命周期内必须维护一致性，通俗的讲就是业务规则。</li>
</ul>
</li>
<li>聚合特征<ul>
<li>根实体具有全局的标识，它最终负责检查固定规则。</li>
<li>边界内的实体具有本地标识，这些标识只在聚合内部才是唯一的。</li>
<li>聚合外部的对象不能引用根实体之外的聚合内部对象。根实体可以将内部实体的引用传递给它们，但只能临时使用。或者传递一个值对象的副本出去，而不用关心它发生了什么变化。</li>
<li>只有根实体才能直接通过数据库直接查询，其他对象必须通过遍历关联来发现。</li>
<li>根实体可以保持其他根实体的引用。</li>
<li>当对聚合边界内的任何对象做了修改时，整个聚合的所有固定规则都必须被满足。</li>
</ul>
</li>
<li>原则<ul>
<li>通过唯一标识去引用其他聚合<ul>
<li>引用聚合和被引用的聚合不可以在同一个事务中进行修改</li>
<li>如果你在试图在单个事务中修改多个聚合，这往往意味着此时的一致性边界是错误的，发生这样的情况通常是我们遗留了某些建模点，或者尚未发现通用语言中的某个概念。</li>
<li>当试图修改多个聚合的话，我们也应该采用最终一致性而非原子一致性。</li>
</ul>
</li>
<li>利用应用层来处理聚合内的依赖关系，避免在聚合中使用资源库或者领域服务。</li>
<li>边界之外使用最终一致性</li>
</ul>
</li>
</ul>
<h5 id="Service（领域服务）"><a href="#Service（领域服务）" class="headerlink" title="Service（领域服务）"></a>Service（领域服务）</h5><ul>
<li>三个特征<ul>
<li>它是与领域相关的操作如执行一个显著的业务操作过程，但它又并不适合放入实体与值对象中。</li>
<li>操作是无状态的。</li>
<li>对领域对象进行转换，或以多个领域对象作为输入进行计算，结果产生一个值对象。</li>
</ul>
</li>
<li>区分不同的服务<ul>
<li>应用服务：获取输入，发送消息给领域层，监听确认消息，决定使用基础服务来发送邮件。</li>
<li>领域服务：协调账户模型和总账模型进行交互，执行相应的领域行为。</li>
<li>基础服务：按照应用服务的指示发送邮件。</li>
</ul>
</li>
<li>粒度<ul>
<li>我们应该尽量避免领域知识泄露到应用层当中去。那此时领域服务就不失为一种良好的处理方式，通过将细粒度的领域对象封装到领域服务当中去，将领域知识限制在领域服务当中，形成粗粒度的领域对象。</li>
</ul>
</li>
<li><h2 id="转换过程"><a href="#转换过程" class="headerlink" title="转换过程"></a>转换过程</h2></li>
</ul>
<h5 id="Domain-Event（领域事件）"><a href="#Domain-Event（领域事件）" class="headerlink" title="Domain Event（领域事件）"></a>Domain Event（领域事件）</h5><ul>
<li><p>领域专家所关心的发生在领域中的一些事件。将领域中所发生的活动建模成一系列的离散事件。每个事件都用领域对象来表示…领域事件是领域模型的组成部分，表示领域中所发生的事情。</p>
</li>
<li><p>一个领域事件必须对业务有价值，有助于形成完整的业务闭环，也即一个领域事件将导致进一步的业务操作。</p>
</li>
<li><p>事件风暴</p>
<ul>
<li><p>事件风暴是一项团队活动，旨在通过领域事件识别出聚合根，进而划分微服务的限界上下文。</p>
<blockquote>
<p>在活动中，团队先通过头脑风暴的形式罗列出领域中所有的领域事件，整合之后形成最终的领域事件集合，然后对于每一个事件，标注出导致该事件的命令（Command），再然后为每个事件标注出命令发起方的角色，命令可以是用户发起，也可以是第三方系统调用或者是定时器触发等。最后对事件进行分类整理出聚合根以及限界上下文。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h5 id="Factory"><a href="#Factory" class="headerlink" title="Factory"></a>Factory</h5><ul>
<li>why<ul>
<li>隐藏创建的细节</li>
<li>对内，复杂对象除了本身生命周期的维护外，如果再承担自身的创建，会导致负载过重</li>
<li>对外，不需要客户理解对象创建过程</li>
</ul>
</li>
<li>定义<ul>
<li>复杂对象的创建是领域层的职责，但这项任务并不一定属于那些用于表示模型的对象，他们没有对应模型中的事物，但又确实承担了领域层的职责。</li>
<li>应该将创建复杂对象和聚合的职责转移给单独的对象，这个对象本身可能没有承担领域模型中的职责，但它仍然领域设计的一部分。</li>
<li>在创建聚合时要把它作为一个整体，并确保它满足固定规则。</li>
</ul>
</li>
<li>设计要点<ul>
<li>每个创建方法都应该是原子的，并保证生成的对象处于一致的状态。</li>
<li>可以使用独立的工厂或者在聚合根上使用工厂方法。</li>
<li>工厂方法的参数应该是较低层的对象。</li>
<li>非必要场景，直接构造函数即可<ul>
<li>类仅仅是一种类型，没有其他子类，没有实现多态性。</li>
<li>客户关心的是实现类。</li>
<li>客户可以访问对象的所有属性，因此向客户公开的构造函数中没有嵌套的对象创建。</li>
<li>构造过程很简单。</li>
<li>公共构造函数必须遵守与工厂相同的规则，必须是原子操作且满足所有固定规则。</li>
<li>不要在构造函数中调用其他构造函数，应保持构造函数的简单。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h5><ul>
<li>实现<ul>
<li>对类型抽象</li>
<li>充分利用与客户进行解藕</li>
<li>事务的控制权交给客户</li>
</ul>
</li>
<li>优点<ul>
<li>为客户提供了一个简单的模型，可用来获取持久化对象并管理他们的生命周期</li>
<li>他们将应用程序和领域设计与持久化技术进行解耦</li>
<li>它们体现了有关对象访问的设计决策</li>
<li>很容易测试，将利用集合直接替换资源库进行测试</li>
</ul>
</li>
</ul>
<h5 id="Bounded-Context-限定上下文"><a href="#Bounded-Context-限定上下文" class="headerlink" title="Bounded Context (限定上下文)"></a>Bounded Context (限定上下文)</h5><ul>
<li>领域、子域、限界上下文<ul>
<li>领域即是一个组织所做的事情以及其中所包含的一切</li>
<li>模型只在限界上下文中变动，不影响其他限界上下文，将变动的影响范围控制在单个限界上下文中</li>
<li>一般来说，一个子域对应一个限界上下文，但是子域并不一定与限界上下文一一对应</li>
<li>领域种类划分<ul>
<li>核心域：公司主要的业务领域，比如生鲜的商品子域以及订单子域（核心域并不绝对）</li>
<li>支撑子域：公司的库存帮助公司完成销售。他们就属于支撑子域。</li>
<li>通用子域：会员子域，在许多的网上购物平台上都会使用到的会员体系。它属于通用子域。</li>
</ul>
</li>
</ul>
</li>
<li>限界上下文是一个显式的边界，领域存在于这个边界之内。</li>
</ul>
<h5 id="Context-Map（上下文映射）"><a href="#Context-Map（上下文映射）" class="headerlink" title="Context Map（上下文映射）"></a>Context Map（上下文映射）</h5><img src="/images/DDD-领域建模/image-20210311142539037.png" alt="image-20210311142539037" style="zoom:30%;" />

<ul>
<li>继承方式<ul>
<li>RPC</li>
<li>Restful等api</li>
<li>消息队列</li>
</ul>
</li>
<li>种类<ul>
<li>共享内核-Shared Kernel</li>
<li>客户/供应商-Customer/Supplier</li>
<li>追随者-Conformist</li>
<li>防腐层-Anticorruption Layer</li>
<li>公开主机服务-Open Host Service</li>
<li>各行其道  - Separate Way</li>
<li>合作关系 - Partnership</li>
</ul>
</li>
</ul>
<h4 id="设计方法"><a href="#设计方法" class="headerlink" title="设计方法"></a>设计方法</h4><h5 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h5><img src="/images/DDD-领域建模/image-20210311111555717.png" alt="image-20210311111555717" style="zoom:35%;" />

<ul>
<li>基本原则：每层只能和位于下方的层产生耦合<ul>
<li>严格分层架构：每层只能与直接位于下方的层发生耦合</li>
<li>松散分层架构：任意上层和任意下层发生耦合</li>
<li>可以通过观察者等模式，让下层和上层发生耦合</li>
</ul>
</li>
</ul>
<h5 id="六边形架构"><a href="#六边形架构" class="headerlink" title="六边形架构"></a>六边形架构</h5><img src="/images/DDD-领域建模/image-20210311111942873.png" alt="image-20210311111942873" style="zoom:35%;" />

<ul>
<li>六边形架构 其实是分层架构的一种扩展，是原来分层架构的另外一种解读，是一种端口+适配器风格的架构</li>
<li>通过端口+适配器将领域包裹起来， 形成清晰的应用程序边界</li>
</ul>
<h5 id="SOA"><a href="#SOA" class="headerlink" title="SOA"></a>SOA</h5><ul>
<li>SOA原则<ul>
<li>服务契约</li>
<li>松耦合</li>
<li>服务抽象</li>
<li>服务重用性</li>
<li>服务自治性</li>
<li>服务无状态性</li>
<li>服务可发现性</li>
<li>服务组合性</li>
</ul>
</li>
<li>SOA 精神所在<ul>
<li>业务价值高于技术策略</li>
<li>战略目标高于项目利益</li>
</ul>
</li>
</ul>
<h5 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h5><ul>
<li>将RESTful和DDD结合的2种方式<ul>
<li>为系统接口层单独创建一个限界上下文</li>
<li>使用标准媒体类型的时候，如果某种媒体类型不用于支持单个系统接口，我们可以可以创建一个领域模型来处理。</li>
</ul>
</li>
</ul>
<h5 id="CQRS"><a href="#CQRS" class="headerlink" title="CQRS"></a>CQRS</h5><h5 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h5><h4 id="ContextMapper"><a href="#ContextMapper" class="headerlink" title="ContextMapper"></a>ContextMapper</h4><img src="/images/DDD-领域建模/image-20210315200928557.png" alt="image-20210315200928557" style="zoom:50%;" />

<h5 id="ContextMap"><a href="#ContextMap" class="headerlink" title="ContextMap"></a>ContextMap</h5><ul>
<li>contextMap 只有2种type<ul>
<li>SYSTEM_LANDSCAPE 这个是从系统层面描述 ContextMap</li>
<li>ORGANIZATIONAL 这个是从组织团队层面描述 ContextMap</li>
</ul>
</li>
</ul>
<h5 id="BoundedContext"><a href="#BoundedContext" class="headerlink" title="BoundedContext"></a>BoundedContext</h5><ul>
<li>一个BoundedContext 可以实现多个domain</li>
<li>一个BoundedContext 可以 refines 另外一个</li>
<li>BoundedContext  类型有4种<ul>
<li>FEATURE</li>
<li>APPLICATION</li>
<li>SYSTEM</li>
<li>TEAM</li>
</ul>
</li>
<li>Knowage level 有2个<ul>
<li>CONCRETE</li>
<li>META</li>
</ul>
</li>
</ul>
<h5 id="Domain-and-Subdomain"><a href="#Domain-and-Subdomain" class="headerlink" title="Domain and Subdomain"></a>Domain and Subdomain</h5><img src="/images/DDD-领域建模/image-20210315201429551.png" alt="image-20210315201429551" style="zoom:33%;" />

<ul>
<li>Subdomain 类型<ul>
<li>CORE_DOMAIN</li>
<li>SUPPORTING_DOMAIN</li>
<li>GENERIC_SUBDOMAIN</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title>GraphQl 使用 - java</title>
    <url>/2019/08/03/GraphQl-%E4%BD%BF%E7%94%A8-java/</url>
    <content><![CDATA[<p>去年在做内容库的时候，涉及到了多系统多数据源互相查询的情景，当时就想要将内容库的所有数据，增加统一的数据接入层，通过graphql的方式提供给上层业务使用，后面受限于人力没有实施。目前从头开始做站群相关的业务，顺带着浅尝了一下graphql，感觉还不错。</p>
<h2 id="GraphQL-是什么"><a href="#GraphQL-是什么" class="headerlink" title="GraphQL 是什么"></a>GraphQL 是什么</h2><blockquote>
<p>GraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing data. GraphQL provides a complete and understandable description of the data in your API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools.</p>
</blockquote>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>参看:  <a href="https://www.youtube.com/watch?v=Ah6GSCK5Rfs">https://www.youtube.com/watch?v=Ah6GSCK5Rfs</a></p>
<p>graphql 和 rest api 是同一层的东西，都是一种基于 http 之上的数据接口协议，两者设计理念完全不同。目前来说 graphql 在很多大小厂也都开始使用，确实会方便很多。 但是 rest api 还是最广泛应用的协议，比如 AMP (T T)。 事实上任何东西都有2面性，对于graphql 来说，优缺点都有</p>
<span id="more"></span>

<h3 id="与-REST-API-相比的好处"><a href="#与-REST-API-相比的好处" class="headerlink" title="与 REST API 相比的好处"></a>与 REST API 相比的好处</h3><ul>
<li>优点<ul>
<li>一次提供，多次使用<ul>
<li>作为后端，我们只需要关心数据字段的提供，不需要关心前端是怎么用这些字段，页面结构是怎样的</li>
<li>真的不需要频繁的对接口了</li>
</ul>
</li>
<li>动态可扩展，无冗余查询，所见即所得<ul>
<li>因为前端只会请求需要的字段，增加新的字段后，不用担心老的业务请求这些冗余数据，很好的支撑了可扩展性</li>
<li>所见即所得，能够帮助客户端代码不易出错</li>
</ul>
</li>
<li>多个字段，一次请求<ul>
<li>对于前端来说，面向schema编程，无需知道后端是多少个服务在支撑需要的这些字段，也无需频繁的更改接口去从新服务获取想要的字段，只需要在请求的时候增加一个 field 就好了</li>
</ul>
</li>
<li>代码即文档<ul>
<li>直接通过graphqli 等工具查看schema协议，不需要文档，写注释就好了</li>
</ul>
</li>
<li>类型校验<ul>
<li>在定义好schema的同时，就约束了接口类型，graphql支持强类型校验</li>
</ul>
</li>
<li>…</li>
</ul>
</li>
<li>缺点<ul>
<li>基于post 请求<ul>
<li>传统方式无法监控(nginx)</li>
<li>不能利用 http 自身的缓存机制</li>
</ul>
</li>
<li>没有充分利用http<ul>
<li>只使用了 post 请求，没有其他http的方法：方法的幂等性</li>
<li>缺失了http状态码</li>
</ul>
</li>
<li>配套还不完善<ul>
<li>微服务</li>
<li>监控</li>
<li>分流</li>
</ul>
</li>
<li>…</li>
</ul>
</li>
</ul>
<h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><h3 id="几个基本概念"><a href="#几个基本概念" class="headerlink" title="几个基本概念"></a>几个基本概念</h3><p>最好参看官方文档：<a href="https://graphql.github.io/graphql-spec/June2018/">https://graphql.github.io/graphql-spec/June2018/</a></p>
<p>中文版的可以查看：<a href="https://spec.graphql.cn/#sec-Overview-">https://spec.graphql.cn/#sec-Overview-</a></p>
<p>概念很多，摘了几个出来，在实际业务场景中使用的话，还是有很多需要探的地方，这里只是大概的一个介绍</p>
<ul>
<li>schema<ul>
<li>相当于协议文件，定义了所有对象的类型和查询接口</li>
<li>一般定义的操作是2个： query/ mutation , 一个用于读，一个用于写，也存在subscription的操作</li>
</ul>
</li>
<li>type<ul>
<li>graphql 有自己的一套类型系统，有8种类型<ul>
<li>scalars/标量</li>
<li>objects/对象</li>
<li>interfaces/接口</li>
<li>unions/联合</li>
<li>Enums/枚举</li>
<li>Input objects/输入类型</li>
<li>lists/列表</li>
<li>Non-null/非空型</li>
</ul>
</li>
<li>graphql 有自己的基本类型，也可以自定义一些类型，但是需要相应的解释器</li>
</ul>
</li>
<li>内省 -&gt; 验证 -&gt; 执行 -&gt; 响应</li>
<li>datafetcher<ul>
<li>实现过程中，定义了字段的获取方法</li>
</ul>
</li>
</ul>
<h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><p>具体的代码可以参看： <a href="https://github.com/xtestw/graphql-demo">https://github.com/xtestw/graphql-demo</a></p>
<ul>
<li><p>引入 graphql 的依赖包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;com.graphql-java&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;graphql-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;13.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>定义 schema 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">schema &#123;</span><br><span class="line">  query: Query</span><br><span class="line">  mutation: Mutation</span><br><span class="line">&#125;</span><br><span class="line">scalar Date</span><br><span class="line"></span><br><span class="line">type Query &#123;</span><br><span class="line">  student(id:Int!):Student</span><br><span class="line">  students(pagination:Pagination):[Student]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Mutation &#123;</span><br><span class="line">  add(newStudent:NewStudent):Student</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">input Pagination&#123;</span><br><span class="line">  index: Int!</span><br><span class="line">  size: Int!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">input NewStudent&#123;</span><br><span class="line">  name:String!</span><br><span class="line">  sex:Sex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Student &#123;</span><br><span class="line">  id: Int</span><br><span class="line">  name: String</span><br><span class="line">  sex: Sex</span><br><span class="line">  creation: Date</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum Sex&#123;</span><br><span class="line">  MALE,FEMALE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实现 schema 文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xtestw.graphql.demo.schema.wiring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.ImmutableMap;</span><br><span class="line"><span class="keyword">import</span> com.xtestw.graphql.demo.schema.model.NewStudent;</span><br><span class="line"><span class="keyword">import</span> com.xtestw.graphql.demo.schema.model.Pagination;</span><br><span class="line"><span class="keyword">import</span> com.xtestw.graphql.demo.storage.Student;</span><br><span class="line"><span class="keyword">import</span> com.xtestw.graphql.demo.storage.Student.Sex;</span><br><span class="line"><span class="keyword">import</span> com.xtestw.graphql.demo.storage.repository.StudentRepository;</span><br><span class="line"><span class="keyword">import</span> graphql.schema.DataFetchingEnvironment;</span><br><span class="line"><span class="keyword">import</span> graphql.schema.idl.MapEnumValuesProvider;</span><br><span class="line"><span class="keyword">import</span> graphql.schema.idl.TypeRuntimeWiring;</span><br><span class="line"><span class="keyword">import</span> graphql.schema.idl.TypeRuntimeWiring.Builder;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create by xuwei on 2019/8/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentWiring</span> <span class="keyword">implements</span> <span class="title class_">Wiring</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  StudentRepository studentRepository;</span><br><span class="line">  <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> List&lt;TypeRuntimeWiring&gt; <span class="title function_">wireTypes</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.singletonList(</span><br><span class="line">        TypeRuntimeWiring.newTypeWiring(<span class="string">&quot;Sex&quot;</span>)</span><br><span class="line">            .enumValues(<span class="keyword">new</span> <span class="title class_">MapEnumValuesProvider</span>(</span><br><span class="line">                ImmutableMap.of(</span><br><span class="line">                    <span class="string">&quot;MALE&quot;</span>, Sex.MALE,</span><br><span class="line">                    <span class="string">&quot;FEMALE&quot;</span>, Sex.FEMALE</span><br><span class="line">                )))</span><br><span class="line">            .build());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wireQueries</span><span class="params">(Builder queryBuilder)</span> &#123;</span><br><span class="line">    queryBuilder.dataFetcher(<span class="string">&quot;student&quot;</span>, <span class="built_in">this</span>::fetchStudentById)</span><br><span class="line">        .dataFetcher(<span class="string">&quot;students&quot;</span>, <span class="built_in">this</span>::fetchStudents);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;Student&gt; <span class="title function_">fetchStudents</span><span class="params">(DataFetchingEnvironment dataFetchingEnvironment)</span> &#123;</span><br><span class="line">    <span class="type">Pagination</span> <span class="variable">pagination</span> <span class="operator">=</span> mapper</span><br><span class="line">        .convertValue(dataFetchingEnvironment.getArgument(<span class="string">&quot;pagination&quot;</span>), Pagination.class);</span><br><span class="line">    <span class="keyword">if</span> (pagination == <span class="literal">null</span>) &#123;</span><br><span class="line">      pagination = Pagination.create(<span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> studentRepository.findAll(pagination.toPageable()).getContent();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Student <span class="title function_">fetchStudentById</span><span class="params">(DataFetchingEnvironment dataFetchingEnvironment)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> dataFetchingEnvironment.getArgument(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> studentRepository.findById(id).orElse(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wireMutations</span><span class="params">(Builder mutationBuilder)</span> &#123;</span><br><span class="line">    mutationBuilder.dataFetcher(<span class="string">&quot;add&quot;</span>, <span class="built_in">this</span>::addNewStudent);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Student <span class="title function_">addNewStudent</span><span class="params">(DataFetchingEnvironment dataFetchingEnvironment)</span> &#123;</span><br><span class="line">    <span class="type">NewStudent</span> <span class="variable">newStudent</span> <span class="operator">=</span> mapper</span><br><span class="line">        .convertValue(dataFetchingEnvironment.getArgument(<span class="string">&quot;newStudent&quot;</span>), NewStudent.class);</span><br><span class="line">    <span class="keyword">return</span> studentRepository.save(newStudent.toStudent());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>构建 GraphqQL 对象实例</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xtestw.graphql.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xtestw.graphql.demo.schema.ExtendedScalars;</span><br><span class="line"><span class="keyword">import</span> com.xtestw.graphql.demo.schema.wiring.Wiring;</span><br><span class="line"><span class="keyword">import</span> graphql.GraphQL;</span><br><span class="line"><span class="keyword">import</span> graphql.GraphQLException;</span><br><span class="line"><span class="keyword">import</span> graphql.schema.GraphQLScalarType;</span><br><span class="line"><span class="keyword">import</span> graphql.schema.GraphQLSchema;</span><br><span class="line"><span class="keyword">import</span> graphql.schema.idl.RuntimeWiring;</span><br><span class="line"><span class="keyword">import</span> graphql.schema.idl.SchemaGenerator;</span><br><span class="line"><span class="keyword">import</span> graphql.schema.idl.SchemaParser;</span><br><span class="line"><span class="keyword">import</span> graphql.schema.idl.TypeDefinitionRegistry;</span><br><span class="line"><span class="keyword">import</span> graphql.schema.idl.TypeRuntimeWiring;</span><br><span class="line"><span class="keyword">import</span> graphql.schema.idl.errors.SchemaProblem;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create by xuwei on 2019/8/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GraphQLConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Value(&quot;classpath*:schemas/*.graphqls&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> Resource[] files;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  GraphQL <span class="title function_">graphQL</span><span class="params">(<span class="meta">@Autowired</span> GraphQLSchema graphQLSchema)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> GraphQL.newGraphQL(graphQLSchema)</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  GraphQLSchema <span class="title function_">graphQLSchema</span><span class="params">(<span class="meta">@Autowired</span> RuntimeWiring wiring)</span> &#123;</span><br><span class="line">    <span class="type">SchemaParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SchemaParser</span>();</span><br><span class="line">    <span class="type">TypeDefinitionRegistry</span> <span class="variable">typeDefinitionRegistry</span> <span class="operator">=</span> Arrays.stream(files).map(file -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> file.getInputStream();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Load graphql file error: &#123;&#125; - &#123;&#125;&quot;</span>, file, e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;).filter(Objects::nonNull)</span><br><span class="line">        .map(inputStream -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> parser.parse(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream));</span><br><span class="line">          &#125; <span class="keyword">catch</span> (SchemaProblem e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">GraphQLException</span>(</span><br><span class="line">                String.format(<span class="string">&quot;Compile schema &#x27;%s&#x27; failed: %s&quot;</span>, inputStream,</span><br><span class="line">                    e.getErrors().stream().map(Object::toString).collect(Collectors.toList())), e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;).reduce(<span class="keyword">new</span> <span class="title class_">TypeDefinitionRegistry</span>(), (all, cur) -&gt; &#123;</span><br><span class="line">          all.merge(cur);</span><br><span class="line">          <span class="keyword">return</span> all;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SchemaGenerator</span>().makeExecutableSchema(typeDefinitionRegistry, wiring);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  RuntimeWiring <span class="title function_">wiring</span><span class="params">(<span class="meta">@Autowired</span> List&lt;GraphQLScalarType&gt; scalarTypes,</span></span><br><span class="line"><span class="params">      <span class="meta">@Autowired</span> List&lt;TypeRuntimeWiring&gt; types)</span> &#123;</span><br><span class="line">    RuntimeWiring.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> RuntimeWiring.newRuntimeWiring();</span><br><span class="line">    <span class="keyword">if</span> (scalarTypes != <span class="literal">null</span>) &#123;</span><br><span class="line">      scalarTypes.forEach(builder::scalar);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (types != <span class="literal">null</span>) &#123;</span><br><span class="line">      types.forEach(builder::type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builder.build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  List&lt;GraphQLScalarType&gt; <span class="title function_">scalarTypes</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.singletonList(ExtendedScalars.GraphQLDate);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  List&lt;TypeRuntimeWiring&gt; <span class="title function_">types</span><span class="params">(<span class="meta">@Autowired</span> List&lt;Wiring&gt; wirings)</span> &#123;</span><br><span class="line"></span><br><span class="line">    TypeRuntimeWiring.<span class="type">Builder</span> <span class="variable">queryBuilder</span> <span class="operator">=</span> TypeRuntimeWiring.newTypeWiring(<span class="string">&quot;Query&quot;</span>);</span><br><span class="line">    TypeRuntimeWiring.<span class="type">Builder</span> <span class="variable">mutationBuilder</span> <span class="operator">=</span> TypeRuntimeWiring.newTypeWiring(<span class="string">&quot;Mutation&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> wirings.stream().map(wiring -&gt; &#123;</span><br><span class="line">      wiring.wireQueries(queryBuilder);</span><br><span class="line">      wiring.wireMutations(mutationBuilder);</span><br><span class="line">      <span class="keyword">return</span> wiring.wireTypes();</span><br><span class="line">    &#125;)</span><br><span class="line">        .reduce(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(queryBuilder.build(), mutationBuilder.build())),</span><br><span class="line">            (all, cur) -&gt; &#123;</span><br><span class="line">              all.addAll(cur);</span><br><span class="line">              <span class="keyword">return</span> all;</span><br><span class="line">            &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>定义接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xtestw.graphql.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.JsonNode;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.type.MapType;</span><br><span class="line"><span class="keyword">import</span> com.xtestw.graphql.demo.schema.model.Query;</span><br><span class="line"><span class="keyword">import</span> graphql.GraphQL;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.CrossOrigin;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create by xuwei on 2019/8/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/graphql&quot;)</span></span><br><span class="line"><span class="meta">@CrossOrigin</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GraphQLController</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line">  GraphQL graphQL;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostMapping(path = &#123;&quot;&quot;&#125;)</span></span><br><span class="line">  <span class="keyword">private</span> Object <span class="title function_">query</span><span class="params">(<span class="meta">@RequestBody</span> String queryStr)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> getQuery(queryStr);</span><br><span class="line">    <span class="keyword">return</span> graphQL.execute(query.toExecutionInput());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">MapType</span> <span class="variable">VARIABLES_TYPE</span> <span class="operator">=</span> mapper.getTypeFactory()</span><br><span class="line">      .constructMapType(HashMap.class,</span><br><span class="line">          String.class, Object.class);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Query <span class="title function_">getQuery</span><span class="params">(String queryText)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">operationName</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">fullQueryText</span> <span class="operator">=</span> queryText;</span><br><span class="line">    Map&lt;String, Object&gt; variables = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">JsonNode</span> <span class="variable">jsonBody</span> <span class="operator">=</span> mapper.readTree(queryText);</span><br><span class="line">    <span class="keyword">if</span> (jsonBody != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">JsonNode</span> <span class="variable">queryNode</span> <span class="operator">=</span> jsonBody.get(<span class="string">&quot;query&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (queryNode != <span class="literal">null</span> &amp;&amp; queryNode.isTextual()) &#123;</span><br><span class="line">        queryText = queryNode.asText();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">JsonNode</span> <span class="variable">operationNameNode</span> <span class="operator">=</span> jsonBody.get(<span class="string">&quot;operationName&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (operationNameNode != <span class="literal">null</span> &amp;&amp; operationNameNode.isTextual()) &#123;</span><br><span class="line">        operationName = operationNameNode.asText();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">JsonNode</span> <span class="variable">variablesNode</span> <span class="operator">=</span> jsonBody.get(<span class="string">&quot;variables&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (variablesNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (variablesNode.isTextual()) &#123;</span><br><span class="line">          <span class="type">String</span> <span class="variable">variablesJson</span> <span class="operator">=</span> variablesNode.asText();</span><br><span class="line">          variables = mapper.convertValue(mapper.readTree(variablesJson), VARIABLES_TYPE);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (variablesNode.isObject()) &#123;</span><br><span class="line">          variables = mapper.convertValue(variablesNode, VARIABLES_TYPE);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (variables == <span class="literal">null</span>) &#123;</span><br><span class="line">      variables = Collections.emptyMap();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Query</span>(fullQueryText, queryText, operationName, variables);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
</li>
</ul>
<p><img src="/var/folders/84/6jh1114j4rx6m0b5h4w5_45h0000gn/T/abnerworks.Typora/image-20190804164253298.png" alt="image-20190804164253298"></p>
<p><img src="/var/folders/84/6jh1114j4rx6m0b5h4w5_45h0000gn/T/abnerworks.Typora/image-20190804164354974.png" alt="image-20190804164354974"></p>
<p><img src="/var/folders/84/6jh1114j4rx6m0b5h4w5_45h0000gn/T/abnerworks.Typora/image-20190804164517506.png" alt="image-20190804164517506"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>graphql 相比较 restapi 来说，各有优缺点。个人感觉 graphql的前景还是很大的，目前最大的问题其实还是相关的生态和基础设施还不够完善，也存在很大的迁移成本和学习成本。不过单纯从数据获取的角度来说，非常有优势！此处我们只做了一个非常浅的探索。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>New Skill</category>
        <category>GraphQL</category>
      </categories>
      <tags>
        <tag>graphql</tag>
        <tag>graphiql</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>Ha3 学习笔记</title>
    <url>/2021/02/28/Ha3-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><img src="/images/Ha3-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210228184558960.png" alt="image-20210228184558960"></p>
<p>ha3本身是阿里系针对自己的场景自己研发的搜索引擎平台，也是基于自身的技术积累之上构建的，包括依赖的系统和代码库，都是自研自足的。经历了近10年的发展，也经受了核心场景双十一的考验，已经是一套非常完善成熟的系统，值得学习和研究。 图中为ha3的基本架构，比较简洁，主要分为数据源聚合(俗称 dump)、全量/增量/实时索引构建及在线服务等部分，其中数据源聚合在 tisplus 平台和 Blink 平台完成，核心有以下几个模块：</p>
<ul>
<li>QRS<ul>
<li>输入的查询解析/校验，转发searcher</li>
<li>searcher 结果合并加工返回用户</li>
</ul>
</li>
<li>Searcher<ul>
<li>文档召回服务，包含打分/排序/summary</li>
</ul>
</li>
<li>Build Service<ul>
<li>全量/增量/实时索引构建，提供给在线服务使用</li>
</ul>
</li>
<li>其他<ul>
<li>hippo: 调度系统，分配机器</li>
<li>suez/suze_ops，引擎管控/任务分发</li>
<li>deploy express，用于分发包，索引，配置等数据</li>
<li>swift，消息队列</li>
<li>cm2/vipserver，域名解析/服务发现</li>
</ul>
</li>
</ul>
<span id="more"></span>

<p>整个ha3作为一个完善的搜索引擎，方方面面都很涉及，本文主要围绕索引和检索两个过程进行讨论，其他的包括插件、检索语法、配置、运维等方面，不在本文叙述。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引的作用是为了增加检索速度，ha3索引主要是基于indexlib库构建的。indexlib的索引类型支持 index索引/kv索引/kkv索引/时序索引等。</p>
<p>在我们搜索场景中，主要使用index索引，index索引主要用于基于关键词进行文档检索召回的场景，并对召回的文档基于文档属性进行进一步的过滤、统计、排序等操作。 </p>
<p>index索引是基于文档进行的，每个文档都会有一个docid(docid类型为int32_t，所以最多支持20亿文档)。 而每个文档都是由多个field组成，每个field会对应为：主键索引(primary key index)、倒排索引(index)、正排索引(attribute)、摘要(summary)</p>
<p>本章主要针对index索引，介绍其索引的结构和构建的过程，以便我们更好的理解索引的作用，以及后面的检索过程。</p>
<h3 id="索引格式"><a href="#索引格式" class="headerlink" title="索引格式"></a>索引格式</h3><p><img src="/images/Ha3-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210228195329797.png" alt="image-20210228195329797"></p>
<p>上图是整个索引文件列表，针对目录的说明如下：</p>
<table>
<thead>
<tr>
<th>结构名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>generation</td>
<td>generation_x是引擎区分不同版本全量索引的标识。</td>
</tr>
<tr>
<td>partition</td>
<td>partition是searcher加载索引的基本单位。如果一个partition中数据过多，会导致searcher性能降低。线上数据一般通过划分多个partition的方式来保证每个searcher的检索效率。</td>
</tr>
<tr>
<td>segment</td>
<td>segment是索引组成的基本单位。segment中包含了文档的倒排和正排结构。index builder每次dump都会生成一个segment。多个segment可以通过merge策略进行合并。一个partition中可用的segment在version文件中指明。</td>
</tr>
<tr>
<td>index</td>
<td>倒排索引的基本单位。</td>
</tr>
<tr>
<td>attribute</td>
<td>正排索引的基本单位。</td>
</tr>
<tr>
<td>deletionmap</td>
<td>删除的doc记录。</td>
</tr>
<tr>
<td>truncate_meta</td>
<td>截断索引meta数据文件（Index表倒排截断场景 ）。</td>
</tr>
<tr>
<td>adaptive_bitmap_meta</td>
<td>自适应bitmap高频词表文件（Index表倒排应用adaptive_bitmap场景）。</td>
</tr>
</tbody></table>
<p>涉及到的文件如下：</p>
<table>
<thead>
<tr>
<th>文件名称</th>
<th>存储内容</th>
</tr>
</thead>
<tbody><tr>
<td>index_format_version</td>
<td>索引的版本信息。用于检查索引文件是否符合binary要求。</td>
</tr>
<tr>
<td>index_partition_meta</td>
<td>存储了全局排序的信息。包括排序字段和升降序。</td>
</tr>
<tr>
<td>schema.json</td>
<td>索引配置文件。主要记录fields，index, attribute 和summary等信息。引擎通过该文件来加载索引。</td>
</tr>
<tr>
<td>version.0</td>
<td>version文件。主要记录当前partition中引擎需要加载的segment和最新doc的时间戳。在实时build中，引擎会根据增量version的时间戳过滤旧的原始文档。</td>
</tr>
<tr>
<td>segment_info</td>
<td>segment信息摘要。记录了当前segment中文档数目，当前segment是否merge过，locator信息和最新doc时间戳信息。</td>
</tr>
</tbody></table>
<h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h4><p><img src="/images/Ha3-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210228205126548.png" alt="image-20210228205126548"></p>
<p>倒排索引核心解决的问题是建立关键词到doc_id的映射, 通过倒排索引，我们可以快速获取相关的文档列表，以及倒排词在文档中的位置词频等信息。 整个检索流程可以参考上图，先通过词典文件查询索引词在索引文件中的位置，在对应位置获取关联的文档列表信息，以及关键词和关键词在文档中的信息。</p>
<p>除了上图存在的内容外，还存在一个截断索引的概念，这是一种辅助索引，对于原始索引中高频词的倒排链，按照某些feature，截取权重较高的文档形成截断索引，提高检索速度。实际应用中，可以更具多个截断方式，生成多条截断链。</p>
<p>此外，在ha3中，倒排索引记录的主要信息如下, 对于不同的索引(NUMBER/TEXT/PACK/EXPACK/PRIMARYKEY64/RANGE/SPATIAL)，支持也不一样，具体参看文档：</p>
<table>
<thead>
<tr>
<th>信息名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ttf</td>
<td>全称：total term frequency, 表示检索词在所有文档中出现的总次数</td>
</tr>
<tr>
<td>df</td>
<td>全称：document frequency, 表示包含检索词的文档总数</td>
</tr>
<tr>
<td>tf</td>
<td>全称：term frequency, 表示检索词在文档中出现的次数</td>
</tr>
<tr>
<td>docid</td>
<td>全称：document id, 是文档在引擎中的唯一标识，可以通过docid获取到原文档的其他信息</td>
</tr>
<tr>
<td>fieldmap</td>
<td>全称：field map, 用于记录包含检索词的field信息</td>
</tr>
<tr>
<td>section 信息</td>
<td>用户可以为某些文档分段，然后为每一段添加附属信息。该信息可以在检索时取出，供后续处理使用</td>
</tr>
<tr>
<td>position</td>
<td>用于记录检索词在文档中的位置信息</td>
</tr>
<tr>
<td>positionpayload</td>
<td>全称：position payload, 用户可以为文档不同位置设置payload信息，并可以在检索时取出，供后续处理用</td>
</tr>
<tr>
<td>docpayload</td>
<td>全称：document payload, 用户可以为某些文档添加附属信息，并可以在检索时取出，供后续处理使用</td>
</tr>
<tr>
<td>termpayload</td>
<td>全称：term payload, 用户可以为某些词添加附属信息，并可以在检索时取出，供后续处理使用</td>
</tr>
</tbody></table>
<h4 id="正排索引"><a href="#正排索引" class="headerlink" title="正排索引"></a>正排索引</h4><p>正排索引主要是简历 doc_id -&gt;field 的映射，主要用于检索到 doc_id 后，可以根据 doc_id 快速获取关键字段的值用来统计、排序、过滤。 正派索引支持的字段类型主要包括单值类型和多值类型：</p>
<ul>
<li>单值类型<ul>
<li>只有一个data文件, 其为每一个doc分配固定大小的空间，用来存储对应正排字段的取值，可以通过docID直接定位到data文件中该doc对应信息的存储位置，完成获取信息的操作</li>
</ul>
</li>
<li>多值类型<ul>
<li>有两个文件——data文件和offset文件，其中data文件存储着对应正排字段的字段值信息，offset文件记录了doc对应在data中的偏移量，它为每个doc按照doc顺序分配固定大小的空间，来存储其在data文件中的偏移量，从而获取到对应的正排字段信息</li>
</ul>
</li>
</ul>
<h4 id="摘要索引"><a href="#摘要索引" class="headerlink" title="摘要索引"></a>摘要索引</h4><p>摘要索引将一片文档对应的信息存储在一起，通过docID可以定位该文档信息的存储位置，从而为用户提供摘要信息的存储获取服务。</p>
<p>摘要索引只有两个文件——data文件和offset文件。 通过offset可以直接定位到data中doc的信息。</p>
<h3 id="索引构建"><a href="#索引构建" class="headerlink" title="索引构建"></a>索引构建</h3><p>从构建的角度来说，索引分为全量索引/增量索引/实时索引。ha3 通过 buildservice 来构建索引，基本的流程如下：</p>
<p><img src="/images/Ha3-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210228214152893.png" alt="image-20210228214152893"></p>
<p>全量和增量索引属于离线索引，离线索引依赖于三类BS内部的worker：</p>
<ul>
<li>Processor 从数据源获取原始文档，经过文档处理插件后，转换为Processed文档写入SWIFT中转topic</li>
<li>Builder 负责从SWIFT中读取Processed文档，根据此文档构建索引写入到文件系统。</li>
<li>Merger 对Builder产出全量索引或增量索引文件，按照合并策略进行索引合并，并将产出后的索引写到文件系统中。</li>
</ul>
<p>实时索引属于在线索引，构建在在线服务内部，通过RealtimeBuilder模块，直接从中转swift topic(s) 中读取数据（对应图中的实时数据流）、构建索引。可以达到秒级延迟。</p>
<h3 id="索引加载"><a href="#索引加载" class="headerlink" title="索引加载"></a>索引加载</h3><p>索引的加载方式目前只支持mmap加载和blockcache加载 2 种方式：</p>
<ul>
<li><p>mmap 加载</p>
<p>通过系统调用mmap将索引文件映射到进程内存地址空间中。加载过程支持mmap lock到内存来保证全内存场景下数据读取完全不读取磁盘数据；也支持mmap非lock场景加载，由操作系统进行内存页缓存管理（采用系统cache方式）。</p>
</li>
<li><p>blockcache 加载</p>
<p>通过blockcache加载模式，可以将索引文件读取的热数据缓存到blockcache中，减少磁盘读取操作。同时数据淘汰策略采用了lru策略，加载和淘汰更加可控（对比mmap非lock的系统cache）。</p>
</li>
</ul>
<h2 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h2><p><img src="/images/Ha3-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210228221141255.png" alt="image-20210228221141255"></p>
<p>检索流程更多是在线过程，整体流程参看照爷整理的流程图，如上图。检索过程主要分为2个阶段，一阶段负责文档的召回和排序，二阶段则是summary的信息不全。</p>
<p>对于多集群召回的结果，默认支持去重机制。 整体查询支持一些高级查询：</p>
<ul>
<li>一阶段/二阶段的独立查询</li>
<li>索引分层，第一层数量不够后重查后面几层</li>
<li>结果数不同重查机制：<ul>
<li>返回的结果数小于research_threshold，同时过程中触发了有可能影响结果数优化的逻辑，才会触发重查</li>
<li>重查时，会关掉所有对结果数有影响的优化逻辑</li>
</ul>
</li>
<li>分层查询</li>
<li>截断链查询</li>
</ul>
<p>此外因为属于在线服务，在每个阶段都会有相应的指标监控，具体如下：</p>
<ul>
<li><p>qrsSessionLatencyIndependentPhase1 : qrs 创建session -&gt; end session</p>
</li>
<li><p>qrsProcessLatencyIndependentPhase1 : qrs begin session -&gt; end session</p>
</li>
<li><p>searcherProcessLatencyPhase1 : searcher begin search -&gt; end serach</p>
</li>
<li><p>sessionLatencyPhase1 : searcher 创建 session -&gt; end search</p>
</li>
<li><p>afterRunGraphLatency ：search图执行完 -&gt; end serach</p>
</li>
<li><p>afterSearchLatency : searcher final sort完 -&gt; end serach</p>
</li>
<li><p>beforeRunGraphLatency : searcher begin search -&gt; 图中第一个节点IsPhaseOneOp开始</p>
</li>
<li><p>beforeSearchLatency : searcher begin search -&gt; 图中seek op开始 multi layer search</p>
</li>
<li><p>extraRankLatency : Ha3SorterOp(final sort)耗时</p>
</li>
<li><p>mergeLatencyPhase1 : qrs result merge， run qrs graph耗时</p>
</li>
<li><p>rankLatency : multi layer search</p>
</li>
<li><p>rerankLatency ：rerank 耗时， rankLatency和rerankLatency加起来是seek op 耗时</p>
</li>
<li><p>runGraphLatency ：search 图执行耗时</p>
</li>
</ul>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ul>
<li><a href="https://www.infoq.cn/article/uyfnarvkz0zxg7ir6beq">https://www.infoq.cn/article/uyfnarvkz0zxg7ir6beq</a></li>
</ul>
]]></content>
      <tags>
        <tag>搜索引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>HttpURLConnection使用http代理</title>
    <url>/2017/08/13/HttpURLConnection%E4%BD%BF%E7%94%A8http%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>工程中的网络请求，有时会需要使用http代理，比较简单的方法是使用apache的httpclient 直接设置代理，但有的时候使用java自带的HttpURLConnection的时候，就需要注意多线程的问题了。 使用HttpURLConnection 实现代理的方法也很简单，在建立连接之前先设置代理：</p>
<p>Authenticator.setDefault(authenticator);</p>
<p>需要注意的是，设置代理的方法并不是使用HttpURLConnection的一个方法，而在建立请求的时候，也没有任何调用和使用 Authenticator的地方，可以猜测这里设置了代理是使用了全局量，跟进Authenticator中去，会发现： <img src="http://xtestw.site/wp-content/uploads/2017/08/1.png" alt="1"> <img src="http://xtestw.site/wp-content/uploads/2017/08/2.png" alt="2"> 其实setDefault 方法就是设置了一个静态变量，而这个变量被使用的地方在： <img src="http://xtestw.site/wp-content/uploads/2017/08/3.png" alt="3"> （三个同名函数，相同的处理）这个静态变量被全局的网络请求所使用，而不是当前连接独占的配置，一般来说，当前网络使用一个http代理的时候没有问题（比如我们就是通过elb代理多个IP出口），但是当我们有多个代理的时候，在多线程环境下就会出现问题，如果代理服务器的账号密码不同，请求的服务球对cookie和ip进行校验的时候，就会比较麻烦，所以需要想办法来让每一个HttpURLConnection独占这个代理配置，直接的方法似乎没有，但是可以折中，同步网络请求过程中，HttpURLConnection是和唯一线程绑定的，我们可以用ThreadLocal,让每个线程独占一个代理配置，从而间接的保证每个HttpURLConnection始终使用一个代理配置。 可以定一个类：</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalAuthenticator</span> <span class="keyword">extends</span> <span class="title class_">Authenticator</span> &#123;</span><br><span class="line"></span><br><span class="line">  ThreadLocal&lt;PasswordAuthentication&gt; auth = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPasswordAuthentication</span><span class="params">(PasswordAuthentication passwordAuthentication)</span> &#123;</span><br><span class="line">    auth.set(passwordAuthentication);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearPasswordAuthentication</span><span class="params">()</span> &#123;</span><br><span class="line">    auth.remove();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> PasswordAuthentication <span class="title function_">getPasswordAuthentication</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> auth.get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在http网络请求的工具类中定义一个全局的静态ThreadLocalAuthenticator的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadLocalAuthenticator</span> <span class="variable">authenticator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalAuthenticator</span>();</span><br></pre></td></tr></table></figure>

<p>然后在需要的时候使用它就OK了。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>MFC Invalidate闪屏问题</title>
    <url>/2014/06/22/MFC%20Invalidate%E9%97%AA%E5%B1%8F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>使用Invalidate（true），即使在OnDraw中使用了双缓冲，也会出现闪屏问题，下面的解决方案转载自：<a href="http://blog.sina.com.cn/s/blog_60fa20600100igh6.html">http://blog.sina.com.cn/s/blog_60fa20600100igh6.html</a></p>
<p>在使用**Invalidate(TRUE)**进行窗口重绘时，总是会遇到闪屏的问题。</p>
<p>​    一开始以为是绘图速度过慢照成的，但在对绘图时间做了一个测试之后发现，<strong>即使整个绘图过程只持续了几个毫秒，还是会看见很明显的闪烁****，所以时间并不是造成闪烁的决定性因素</strong>。</p>
<p>​    那到底是什么原因呢？现在来看看Invalidate(TRUE)都干了些什么。其实，它只是间接向消息队列添加了<strong>WM_ERASEBKGND</strong>和WM_PAINT两个消息。但是，如果使用Invalidate(FALSE)的话，则只有WM_PAINT消息产生，这时是不会有任何闪烁的。</p>
<p>​    现在看来，闪烁似乎是由WM_ERASEBKGND消息产生的，事实上，的确与它有关。那WM_ERASEBKGND有干了什么呢？WM_ERASEBKGND消息由OnEraseBkgnd()消息处理函数响应，它的作用就是<strong>重绘客户区背景</strong>。我们可以通过向工程里添加WM_ERASEBKGND这个消息，然后在重写的消息处理函数中将返回语句修改为<strong>return TRUE</strong>来屏蔽这一功能，这样做的好处是这时不会重绘背景了，坏处是这时背景也不会被擦出来。</p>
<span id="more"></span>

<p>​    好像还没有说到真实原因，其实真正的原因就隐含在其中。现在来做一个实验，分别尝试一下快速的眨眼和慢速的眨眼，你会发现快速眨眼时我们会感觉眼前的黑色一闪而过，而慢速眨眼时，则会觉得整个过程是连续的，没有什么异样。其实闪烁也就是这么回事，即<strong>多张不连续图像的快速切换</strong>。这里有三个条件，<strong>多张和快速和不连续</strong>，而且需要<strong>同时具备</strong>才会发生闪烁。如果只是两张，只会感觉到突变，还谈不上闪烁；如果频率慢的话，也相当于两张图像的情况了；最后如果是连续图像的话，那就像是看电影，平稳的过渡也不会让人觉得不适。</p>
<p>​    知道了这些，接下来就可以做决策了。</p>
<p>​    <strong>解决方案</strong>：</p>
<p>​    使用Invalidate(FALSE),添加WM_ERASEBKGND消息处理函数或者局部刷新三者选其一，都是可以解决问题的。它们的都是通过除去图像不连续这一因素来达到目的的。</p>
<p>​    另外，要说的是GDI的BitBlt()函数是及其高效的，一次操作所需要的时间只有几到十几个微秒，所以我们可以放心的使用它，而不用担心任何效率问题。不过相对于BitBlt()来说StretchBlt()就要慢的多，大概是几十倍的差别。</p>
<p>​    还有就是一般的绘图工作都是先绘制在一个缓冲区上，然后再一次拷贝到屏幕上。</p>
<p>​    有时，当我们需要利用闪烁的效果的话，也是可以通过多张图像的快速切换来做到，在这里我们也将两张图像的重复切换理解为多张图像。</p>
<p>我自己则是通过下面代码进行解决的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CDQView::OnEraseBkgnd</span><span class="params">(CDC* pDC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//return CView::OnEraseBkgnd(pDC);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>MFC 对话框动态创建简单的GridCtrl控件</title>
    <url>/2014/08/27/MFC%20%E5%AF%B9%E8%AF%9D%E6%A1%86%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E7%AE%80%E5%8D%95%E7%9A%84GridCtrl%E6%8E%A7%E4%BB%B6/</url>
    <content><![CDATA[<p>1.下载安装GridCtrl===&gt;<a href="http://www.codeproject.com/Articles/8/MFC-Grid-control">http://www.codeproject.com/Articles/8/MFC-Grid-control</a></p>
<p>​        在对应项目里面添加GridCtrl的所有.h和cpp的文件(GridCtrl_src和NewCellTypes两个文件夹下的文件)</p>
<p>​        在vs2010中可能会出现CMemDC重定义的错误，只要将CMemDC这个重命名为CGridMemDC（或者其他你想要的名字，同时将这个库中的其他引用CMemDC这个类的地方的名称一起改过来）</p>
<p>2.在对话框中添加GridCtrl的成员变量</p>
<p>​    定义:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CGridCtrl* m_pGrid;</span><br></pre></td></tr></table></figure>

<p>​    构造函数中初始化:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m_pGrid=<span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>​    析构函数中销毁</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (m_pGrid)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> m_pGrid;</span><br><span class="line">    m_pGrid=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.在对话框中画出m_pGrid控件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CRect rect;</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">GetWindowRect</span>(rect);</span><br><span class="line"><span class="built_in">GetClientRect</span>(rect);</span><br><span class="line">m_pGrid=<span class="keyword">new</span> <span class="built_in">CGridCtrl</span>();</span><br><span class="line">m_pGrid-&gt;<span class="built_in">Create</span>(<span class="built_in">CRect</span>(rect.<span class="built_in">TopLeft</span>().x,rect.<span class="built_in">BottomRight</span>().y<span class="number">-100</span>,rect.<span class="built_in">Width</span>(),rect.<span class="built_in">BottomRight</span>().y),<span class="keyword">this</span>,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>其中Create的第一个参数是这个控件在对话框中的位置（我这里是在对话框底部高为100的区域），第二个参数是父窗口句柄，第三个是你分配给他的ID。</p>
<p>这个创建过程，可以根据需求在不同的函数中实现。</p>
<p>这一过程结束之后我们就有了一个空白的GridCtrl控件显示在对话框中了。</p>
<span id="more"></span>

<p>4.构建简单的表格</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m_pGrid-&gt;<span class="built_in">SetEditable</span>(<span class="literal">true</span>);<span class="comment">//默认就是可以编辑的</span></span><br><span class="line"><span class="comment">// m_pGrid-&gt;SetTextBkColor(RGB(0xFF, 0xFF, 0xE0));//设置表格内容是黄色背景</span></span><br><span class="line">m_pGrid-&gt;<span class="built_in">SetRowCount</span>(<span class="number">8</span>); <span class="comment">//初始为8行，包含表头</span></span><br><span class="line">m_pGrid-&gt;<span class="built_in">SetColumnCount</span>(<span class="number">8</span>); <span class="comment">//初始化为8列</span></span><br><span class="line">m_pGrid-&gt;<span class="built_in">SetFixedRowCount</span>(<span class="number">1</span>); <span class="comment">//表头为一行</span></span><br><span class="line">m_pGrid-&gt;<span class="built_in">SetFixedColumnCount</span>(<span class="number">1</span>); <span class="comment">//表头为一列</span></span><br></pre></td></tr></table></figure>

<p>这一步结束之后就是一个8*8的表格，但是表格和表头都还没有内容是空白的</p>
<p>5.操作单元格</p>
<p>可以直接设置对应的单元格的内容</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m_pGrid-&gt;<span class="built_in">SetItemText</span>(row,col,content);</span><br></pre></td></tr></table></figure>

<p>也可以通过下面方式来设置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GV_ITEM Item;</span><br><span class="line">Item.mask = GVIF_TEXT;</span><br><span class="line">Item.row = row;</span><br><span class="line">Item.col = col;</span><br><span class="line">Item.strText = “content<span class="string">&quot;;</span></span><br><span class="line"><span class="string">m_Grid.SetItem(&amp;Item);</span></span><br></pre></td></tr></table></figure>

<p>其中mask表明的是能够访问的单元格的内容，比如我这个地方设置成了GVIF_IMAGE，那么运行结果出来之后在对应的单元格中是看不到content的，而且程序中通过GetItemText()的方法也访问不了(其实就是这个单元格的类型，通过虽然赋值没有报错，但是即便重新设置了mask的值为GVIF_IMAGE,也获取不到之前的赋值)。</p>
<p>mask的类型有下面几种：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GVIF_TEXT      <span class="comment">// Cell text will be accessed</span></span><br><span class="line">GVIF_IMAGE     <span class="comment">// Cell image number will be accessed</span></span><br><span class="line">GVIF_PARAM     <span class="comment">// Cell user data (lParam) will be accessed</span></span><br><span class="line">GVIF_STATE     <span class="comment">// Cell state will be accessed</span></span><br><span class="line">GVIF_BKCLR     <span class="comment">// Cell background colour will be accessed</span></span><br><span class="line">GVIF_FGCLR     <span class="comment">// Cell foreground colour will be accessed</span></span><br><span class="line">GVIF_FORMAT    <span class="comment">// Cell format field will be accessed</span></span><br><span class="line">GVIF_FONT      <span class="comment">// Cell logical font will be accessed</span></span><br><span class="line">GVIF_MARGIN    <span class="comment">// Cell margin information will be accessed </span></span><br><span class="line">GVIF_ALL       <span class="comment">// All information will be accessed</span></span><br></pre></td></tr></table></figure>

<p>到此一个简单的GridCtrl的创建就完成了。</p>
<p>6.添加消息响应函数</p>
<p>以添加完成编辑触发的事件处理函数为例，首先在.h文件中声明消息处理函数:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">afx_msg <span class="type">void</span> <span class="title">OnGridEndEdit</span><span class="params">(NMHDR *pNotifyStruct, LRESULT* pResult)</span></span>;</span><br></pre></td></tr></table></figure>

<p>然后到对应的cpp文件中BEGIN_MESSAGE_MAP和END_MESSAGE_MAP之间添加消息响应映射:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ON_NOTIFY</span>(GVN_ENDLABELEDIT, IDC_GRID, OnGridEndEdit)</span><br></pre></td></tr></table></figure>

<p>其中第一个参数是消息，第二个是GRID创建时候的ID，第三个参数就是对应的消息处理函数</p>
<p>最后在cpp中编写对应的响应函数:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">C3TranformerAttr::OnGridEndEdit</span><span class="params">(NMHDR *pNotifyStruct, LRESULT* pResult)</span></span>&#123;</span><br><span class="line">     NM_GRIDVIEW* pItem = (NM_GRIDVIEW*) pNotifyStruct;</span><br><span class="line">     pItem-&gt;iColumn;</span><br><span class="line">     pItem-&gt;iRow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个函数中可以获得相应的行号和列号，从而进行各种操作。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Millar_rabin和Pollard_Rho</title>
    <url>/2014/06/09/Millar_rabin%E5%92%8CPollard_Rho/</url>
    <content><![CDATA[<p>1.Millar_rabin 素数判定</p>
<p>​     基于以下两个基础：</p>
<p>　　1.如果p是素数，且(a,p)=1,那么(a^(p-1))%p=1(费马小定理)</p>
<p>​      2.对于0&lt;x&lt;p，(x^2)%p=1  =&gt;  x=1 或者 x=p-1</p>
<p>​    处理：</p>
<p>​         把p-1写成u*(2^t)，则a^(p-1)=(a^u)^2^2^2…..t次平方操作</p>
<p>​    过程：</p>
<p>​        随机产生一个数a，cur=a^u %p,对cur做t次平方操作，即cur=cur*cur %p，每次操作结束后，如果cur=1那么上一次的cur必须为1或者p-1否则为合数（上面的基础2），最终的cur必须为1（基础1）。</p>
<p>　注意：</p>
<p>​       long long 在计算乘法的时候要防止溢出，用2进制模拟乘法。</p>
<p>2.Pollard_rho，因数分解</p>
<p>​     用某种方法生成a,b.计算p=gcd(a-b,n)，则p是n的一个因数，如果p=n或者p=1，则迭代的生成a,b，知道p不是n或者1，或者a,b出现循环。（通常b=(a*a+c)%p，在执行之前用Millar_rabin进行素数判定保证n不为素数).</p>
<p>​     过程：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get_facts</span><span class="params">(n)</span></span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (n是素数)&#123;fac[tot++]=n; <span class="keyword">return</span>;&#125;</span><br><span class="line"></span><br><span class="line">　　　　  		p=n</span><br><span class="line"></span><br><span class="line">     while (p&gt;=n) p=Pollard_rho(n,rand()%(p<span class="number">-1</span>)+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">      get_facts(p)</span><br><span class="line"></span><br><span class="line">      get_facts(n/p)</span><br><span class="line"></span><br><span class="line">   end <span class="function"><span class="keyword">func</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACMICPC</category>
      </categories>
  </entry>
  <entry>
    <title>Tarjan算法</title>
    <url>/2013/07/28/Tarjan%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>两篇讲的比较好的文章: <a href="https://www.byvoid.com/blog/scc-tarjan/">https://www.byvoid.com/blog/scc-tarjan/</a> <a href="https://www.byvoid.com/blog/biconnect/">https://www.byvoid.com/blog/biconnect/</a> 对于有向图和无向图，处理的大体方法一样的，不过概念不同 /*****************************************************************************/ tarjan在处理无向图的时候，遇到两点之间的有多条边的时候处理方法，和如何缩点，缩边代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    low[s]=dfn[s]=cnt++;</span><br><span class="line">    vis[s]=<span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    stk.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="comment">//stk[stkCnt++]=s;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=head[s];i!=<span class="number">-1</span>;i=e[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (u==pre)&#123;f++; <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[u])&#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(u,s);</span><br><span class="line">            low[s]=<span class="built_in">min</span>(low[s],low[u]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(vis[u])</span><br><span class="line">            low[s]=<span class="built_in">min</span>(low[s],dfn[u]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (f&gt;=<span class="number">2</span>) <span class="keyword">return</span>;<span class="comment">//这里用f处理了点与点之间如果遇到多条边的情况</span></span><br><span class="line">    <span class="keyword">if</span> (low[s]==dfn[s])&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//int t=stk[--stkCnt];//stk.pop();</span></span><br><span class="line">                <span class="type">int</span> t=stk.<span class="built_in">top</span>();stk.<span class="built_in">pop</span>();</span><br><span class="line">                flag[t]=xx;</span><br><span class="line">                vis[t]=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (t==s)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            xx++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector *nMp;<span class="comment">//[200010];</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">   &#123;<span class="comment">//遍历所有的边，判断边的两边是不是在一个集合中的，不是就是割边</span></span><br><span class="line">       <span class="type">int</span> s,t;</span><br><span class="line">       s=flag[e[i*<span class="number">2</span>].from];</span><br><span class="line">       t=flag[e[i*<span class="number">2</span>].to];</span><br><span class="line">       <span class="keyword">if</span> (s!=t)</span><br><span class="line">       &#123;</span><br><span class="line">           nMp[s].<span class="built_in">push_back</span>(t);</span><br><span class="line">           nMp[t].<span class="built_in">push_back</span>(s);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  2013多校的第二场B题（hdu 4612） ac代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/STACK:1024000000,1024000000&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">vector mp[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> from;</span><br><span class="line">    <span class="type">int</span> to;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line">edge e[<span class="number">2000020</span>];</span><br><span class="line"><span class="type">int</span> head[<span class="number">200020</span>];</span><br><span class="line">stack stk;</span><br><span class="line"><span class="comment">//int stk[200010];</span></span><br><span class="line"><span class="type">int</span> stkCnt=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> flag[<span class="number">200010</span>];</span><br><span class="line"><span class="type">int</span> xx;</span><br><span class="line"><span class="type">int</span> low[<span class="number">200010</span>];</span><br><span class="line"><span class="type">int</span> dfn[<span class="number">200010</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">200010</span>];</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    low[s]=dfn[s]=cnt++;</span><br><span class="line">    vis[s]=<span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    stk.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="comment">//stk[stkCnt++]=s;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=head[s];i!=<span class="number">-1</span>;i=e[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (u==pre)&#123;f++; <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[u])&#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(u,s);</span><br><span class="line">            low[s]=<span class="built_in">min</span>(low[s],low[u]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(vis[u])</span><br><span class="line">            low[s]=<span class="built_in">min</span>(low[s],dfn[u]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (f&gt;=<span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (low[s]==dfn[s])&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//int t=stk[--stkCnt];//stk.pop();</span></span><br><span class="line">                <span class="type">int</span> t=stk.<span class="built_in">top</span>();stk.<span class="built_in">pop</span>();</span><br><span class="line">                flag[t]=xx;</span><br><span class="line">                vis[t]=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (t==s)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            xx++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector *nMp;<span class="comment">//[200010];</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  /\*  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> j=head[i];j!=<span class="number">-1</span>;j=e[j].next)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (flag[e[j].to]!=flag[i])</span><br><span class="line">           &#123;</span><br><span class="line">               nMp[flag[i]].<span class="built_in">push_back</span>(flag[e[j].to]);</span><br><span class="line">               nMp[flag[e[j].to]].<span class="built_in">push_back</span>(flag[i]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;*/</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="type">int</span> s,t;</span><br><span class="line">       s=flag[e[i*<span class="number">2</span>].from];</span><br><span class="line">       t=flag[e[i*<span class="number">2</span>].to];</span><br><span class="line">       <span class="keyword">if</span> (s!=t)</span><br><span class="line">       &#123;</span><br><span class="line">           nMp[s].<span class="built_in">push_back</span>(t);</span><br><span class="line">           nMp[t].<span class="built_in">push_back</span>(s);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans,root;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> pre,<span class="type">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ans&lt;=cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=cnt;</span><br><span class="line">        root=now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nMp[now].<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nMp[now][i]==pre) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(nMp[now][i],now,cnt<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//  int size = 256 &lt;&lt; 20; // 256MB</span></span><br><span class="line"><span class="comment">//  char \*p = (char\*)malloc(size) + size;</span></span><br><span class="line"><span class="comment">//  \_\_asm\_\_(&quot;movl %0, %%esp\\n&quot; :: &quot;r&quot;(p) );</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m)!=EOF)</span><br><span class="line">&#123;</span><br><span class="line">    xx=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(flag,<span class="number">-1</span>,<span class="built_in">sizeof</span>(flag));</span><br><span class="line">    <span class="built_in">memset</span>(low,<span class="number">0</span>,<span class="built_in">sizeof</span>(low));</span><br><span class="line">    <span class="built_in">memset</span>(dfn,<span class="number">0</span>,<span class="built_in">sizeof</span>(dfn));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">   <span class="comment">// memset(stk,0,sizeof(stk));</span></span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in">sizeof</span>(head));</span><br><span class="line">    stkCnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">+5</span>;i++) mp[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">if</span> (m+n==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        e[i].to=b;</span><br><span class="line">        e[i].from=a;</span><br><span class="line">        e[i].next=head[a];</span><br><span class="line">        head[a]=i;</span><br><span class="line">        i++;</span><br><span class="line">        e[i].to=a;</span><br><span class="line">        e[i].from=b;</span><br><span class="line">        e[i].next=head[b];</span><br><span class="line">        head[b]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">tarjan</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    nMp=<span class="keyword">new</span> vector[xx<span class="number">+10</span>];</span><br><span class="line">    <span class="built_in">build</span>(m);</span><br><span class="line">    ans=<span class="number">0</span>;</span><br><span class="line">    root=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(root,root,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\\n&quot;</span>,xx<span class="number">-1</span>-ans);</span><br><span class="line">   <span class="comment">// delete mp;</span></span><br><span class="line">    <span class="keyword">delete</span> nMp;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACMICPC</category>
      </categories>
      <tags>
        <tag>prof</tag>
      </tags>
  </entry>
  <entry>
    <title>UndeclaredThrowableException原因</title>
    <url>/2021/01/17/UndeclaredThrowableException%E5%8E%9F%E5%9B%A0/</url>
    <content><![CDATA[<h1 id="UndeclaredThrowableException-原因"><a href="#UndeclaredThrowableException-原因" class="headerlink" title="UndeclaredThrowableException 原因"></a><em>UndeclaredThrowableException</em> 原因</h1><p>RPC 请求的时候抛出该异常，异常点是 RPC 调用的地方抛出的该异常，除此之外没有其他的异常信息。仔细排查，实际的异常应该是网络IO的TIMEOUT导致的。 那么，就有2个问题需要探讨：</p>
<ul>
<li>为啥抛出的是<em><strong>UndeclaredThrowableException</strong></em>，而不是 <em><strong>TimeOut</strong></em> 的 Exception</li>
<li>如何抛出 <em><strong>TimeOut</strong></em> 异常</li>
</ul>
<h2 id="为啥抛出的是UndeclaredThrowableException"><a href="#为啥抛出的是UndeclaredThrowableException" class="headerlink" title="为啥抛出的是UndeclaredThrowableException"></a>为啥抛出的是<em>UndeclaredThrowableException</em></h2><p>先说结论，之所以抛出这个异常，是因为在RPC调用的实现中，使用了 <em>JDK</em> 动态代理的原因。在 <em>JDK Proxy</em> 的调用中，如果实际运行时(<em>InvocationHandler#invoke</em>) 抛出了某个**受检异常(checked exception)**，但该受检异常并未在被代理对象接口定义中进行声明，那么这个异常就会被 <strong>JVM</strong>包装成 <em><strong>UndeclaredThrowableException</strong></em> 进行抛出。</p>
<p>这里面有个受检异常的概念，简单解释一下，<em><strong>Java</strong></em> 中所有异常，都继承自 <em>java.lang.Throwable</em> 类。</p>
<span id="more"></span>

<p><em><strong>Throwable</strong></em>有两个直接子类，<em><strong>Error</strong></em> 类和 <em><strong>Exception</strong></em> 类。</p>
<p><em><strong>Error</strong></em> 类型用于指示合理的应用程序不应该试图捕获的严重问题, 是一种 <em><strong>UncheckedExcepiton</strong></em></p>
<p><em><strong>Exception</strong></em> 可分为 <em><strong>RuntimeException</strong></em> 和 <em><strong>Checked Exception</strong></em> 两种， 而 <em><strong>RuntimeException</strong></em>是 <em><strong>JVM</strong></em> 正常运行期间抛出的异常的超类时抛出，也是<em><strong>UncheckedExcepiton</strong></em>。</p>
<ul>
<li><p>受检异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.ClassNotFoundException</span><br><span class="line">java.lang.CloneNotSupportedException</span><br><span class="line">java.lang.IllegalAccessException</span><br><span class="line">java.lang.InterruptedException</span><br><span class="line">java.lang.NoSuchFieldException</span><br><span class="line">java.lang.NoSuchMetodException</span><br><span class="line">java.io.IOException</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li><p>非受检异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.ArithmeticException</span><br><span class="line">java.lang.ArrayStoreExcetpion</span><br><span class="line">java.lang.ClassCastException</span><br><span class="line">java.lang.EnumConstantNotPresentException</span><br><span class="line">java.lang.IllegalArgumentException</span><br><span class="line">java.lang.IllegalThreadStateException</span><br><span class="line">java.lang.NumberFormatException</span><br><span class="line">java.lang.IllegalMonitorStateException</span><br><span class="line">java.lang.IllegalStateException</span><br><span class="line">java.lang.IndexOutOfBoundsException</span><br><span class="line">java.lang.ArrayIndexOutOfBoundsException</span><br><span class="line">java.lang.StringIndexOutOfBoundsException</span><br><span class="line">java.lang.NegativeArraySizeException’</span><br><span class="line">java.lang.NullPointerException</span><br><span class="line">java.lang.SecurityException</span><br><span class="line">java.lang.TypeNotPresentException</span><br><span class="line">java.lang.UnsupprotedOperationException</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="如何抛出-TimeOut-异常"><a href="#如何抛出-TimeOut-异常" class="headerlink" title="如何抛出 TimeOut 异常"></a>如何抛出 <em>TimeOut</em> 异常</h2><ul>
<li><p>可以通过<em><strong>UndeclaredThrowableException#getUndeclaredThrowable</strong></em>拿到被包装的受检异常；JDK1.4以后，通过*<strong>Throwable#getCause</strong>也可以拿到被包装的受检异常，而且这是被建议的方式，因为前者已经过时了</p>
</li>
<li><p>实际上，method.invoke的方法申明如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object obj, Object... args)</span> <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException, InvocationTargetException</span><br></pre></td></tr></table></figure>

<p><em>Method.invoke</em> 的方法本身只申明了3种异常，正常调用部分的异常会被 <em>InvocationTargetException</em> 包裹，实际上是 2 层包裹。 另外值得注意的是 <em><strong>InvocationTargetException</strong></em> 本身是受检异常， 既可以包裹受检异常，也可以包裹非受检异常。而 <em><strong>UndeclaredThrowableException</strong></em> 本身是非受检异常， 只可以包裹受检异常</p>
</li>
<li><p>参看 <em><strong>Spring</strong></em>处理方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.springframework.aop.support.AopUtils</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">invokeJoinpointUsingReflection</span><span class="params">(Object target, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use reflection to invoke the method.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ReflectionUtils.makeAccessible(method);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">        <span class="comment">// Invoked method threw a checked exception.</span></span><br><span class="line">        <span class="comment">// We must rethrow it. The client won&#x27;t see the interceptor.</span></span><br><span class="line">        <span class="comment">// 重点在此处：抛出被包装的原始异常</span></span><br><span class="line">        <span class="keyword">throw</span> ex.getTargetException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopInvocationException</span>(<span class="string">&quot;AOP configuration seems to be invalid: tried calling method [&quot;</span> +</span><br><span class="line">                method + <span class="string">&quot;] on target [&quot;</span> + target + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopInvocationException</span>(<span class="string">&quot;Could not access method [&quot;</span> + method + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ 默认构造函数</title>
    <url>/2015/04/03/c++%20%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p><strong>关于c++构造函数两个误解</strong></p>
<ol>
<li><p>任何class只要没有定义构造函数，就会被编译器自动合成一个。 有些构造函数在实际中有和没有是没有任何用处的，所以无用的构造函数是不会被构建出来</p>
</li>
<li><p>编译器合成的构造函数，会为每个成员变量设定初始值 在我看来，编译器合成的构造函数，是为了调用成员类或者父类的构造函数，而这个成员类的构造函数的调用顺序则是按照申明的顺序来调用。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>c++ 子类要正确的调用父类构造函数</title>
    <url>/2015/04/05/cplusplus/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="built_in">base</span>()&#123;</span><br><span class="line">            i=j=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">base</span>(<span class="type">int</span> a,<span class="type">int</span> b)&#123;</span><br><span class="line">            i=a;j=b;</span><br><span class="line">        &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derived</span>:<span class="keyword">public</span> base&#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">derived</span>(<span class="type">int</span> a,<span class="type">int</span> b)&#123;</span><br><span class="line">             <span class="built_in">base</span>(a,b); </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;;    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">　　<span class="function">derived <span class="title">d</span><span class="params">(<span class="number">3</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">　　cout&lt;&lt;d.i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;d.j&lt;&lt;endl;</span><br><span class="line">　　<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的这段代码会输出什么呢？！正确的答案是输出了”0 0”. 我的理解是，虽然其中调用了base(a,b) 但是其实操作的a和b不是当前d的a,b，其实是定义了一个新的base的对象。正确的写法应该是下面这样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="built_in">base</span>()&#123;</span><br><span class="line">            i=j=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">base</span>(<span class="type">int</span> a,<span class="type">int</span> b)&#123;</span><br><span class="line">            i=a;j=b;</span><br><span class="line">        &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dervied</span>:<span class="keyword">public</span> base&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">derived</span>(<span class="type">int</span> a,<span class="type">int</span> b):<span class="built_in">base</span>(a,b)&#123;    </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;;    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">　　<span class="function">derived <span class="title">d</span><span class="params">(<span class="number">3</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">　　cout&lt;&lt;d.i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;d.j&lt;&lt;endl;</span><br><span class="line">　　<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>c++对象模型</title>
    <url>/2016/05/05/cplusplusobjectmodel/</url>
    <content><![CDATA[<p>最近在看《深度探索c++对象模型》对于对象模型有了一点了解，做一个总结。以下的一些结论的实验见：<a href="https://github.com/xtestw/CPPObjModelTest">https://github.com/xtestw/CPPObjModelTest</a></p>
<ul>
<li><a href="#toc_0">c++对象模型</a><ul>
<li>  <a href="#toc_1">单个对象模型</a></li>
<li><a href="#toc_2">单继承对象模型</a><ul>
<li>  <a href="#toc_3">不考虑虚函数的单继承</a></li>
<li>  <a href="#toc_4">考虑虚函数的单继承</a></li>
</ul>
</li>
<li>  <a href="#toc_5">多继承对象模型</a></li>
<li>  <a href="#toc_6">存在虚基类的对象模型</a></li>
</ul>
</li>
</ul>
<h2 id="单个对象模型"><a href="#单个对象模型" class="headerlink" title="单个对象模型"></a>单个对象模型</h2><p>对于一个单个对象而言，对象的内部结构是类似于一张表结构，依次存储着c++的对象内部数据，我们都知道，一个c++的类内部一般会包含下面的几个部分：</p>
<ul>
<li>  非静态成员变量</li>
<li>  非静态成员函数</li>
<li>  静态成员变量</li>
<li>  静态成员函数</li>
<li>  虚函数</li>
<li>  友元函数</li>
<li>  构造函数、析构函数、拷贝构造函数</li>
</ul>
<p>对于一个简单的对象，将设我们定义类如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">base</span>();</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">base</span>();</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> c,d;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>不考虑继承的话，他们的存储结构会是这样的一个结构，如下图： <img src="http://i.imgur.com/lVYnj2P.png"> 其中，非静态数据成员，被放在对象的内部，而虚函数会放在对象的一个虚表中，对象在编译的时候会形成一个vptr的指针置于对象的内部，其指针指向这张虚表（考虑类的继承和多态，指向这张虚表的vptr的设置和重置会在构造函数、析构函数和拷贝函数中自动完成）。 对象在图对象表中的位置，是按照对象的申明顺序来排列的。比如a,b的申明，因为a先申明的，那么a就被先压栈，占据高地址。 而如图所见，不论虚函数是多少个，对象内部只有一个指针指向它，所以始终占一个指针大小的空间（32位机器下是4byte). 而对这个vptr在对象中的位置，不同的编译器的处理是不一样的，vc为代表的是将其放在了头部，而gcc等则是将其放在了对象的尾部，放在尾部是为了综合考虑与C的struct的兼容问题，而在头部，则是考虑继承之后的子类在调用vptr的方便性。(我个人更偏向于放在头部，因为这样在继承的时候更好理解也更方便自然),本文中的代码和模型是基于g++编译器做的实验，都是放在头部的。 还有一个问题，《深度探索c++对象模型》中，对这个1byte的类的type_info位置，他是说放在虚表的第一个位置，而其实g++中，下面这个实验，并不是放在虚表中的：</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">base</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;f&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;f1&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Fun)</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    base b;</span><br><span class="line">    ((Fun)*(<span class="type">int</span>*)*(<span class="type">int</span>*)(&amp;b))();</span><br><span class="line">    ((Fun)*((<span class="type">int</span>*)*(<span class="type">int</span>*)(&amp;b)<span class="number">+1</span>))();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的这段代码的输出是</p>
<pre><code>f
f1
</code></pre>
<p>可见虚表的第一项并不是type_info。</p>
<h2 id="单继承对象模型"><a href="#单继承对象模型" class="headerlink" title="单继承对象模型"></a>单继承对象模型</h2><h3 id="不考虑虚函数的单继承"><a href="#不考虑虚函数的单继承" class="headerlink" title="不考虑虚函数的单继承"></a>不考虑虚函数的单继承</h3><p>在对象申明的过程中，如果从上级单继承了一个对象，那么对父类的成员变量的存储是怎样的一个结构呢，参看下面的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derived</span>:<span class="keyword">public</span> base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> c,d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>子类从父类继承过来的成员变量，无论是private,protected,public,也无论是通过private,protected还是public的方式继承过来的，其在子类中的对象中，都有内存空间来存储它，只是这些成员变量对子类的函数的可访问性的问题而已，不考虑非虚函数和静态变量这些（下面的没说明也是一样）没有存在类里的成员，类内部的结构应该是下面这种情况： <img src="http://i.imgur.com/11kcdkI.png"> 这个地方需要注意的是，如果基类的b不是int类型，而是char类型，而且c,d也都不是int类型，也都是char类型，我们sizeof(derived)的值是多少呢？！ 答案是12！<strong>因为在继承过来的时候，基类已经做了位对齐的处理，在b和c之间填充了3个空字节，</strong>所以，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>（derived)=<span class="built_in">sizeof</span>(base)<span class="number">+1</span>(c)<span class="number">+1</span>(d)<span class="number">+2</span>(padding);</span><br></pre></td></tr></table></figure>

<h3 id="考虑虚函数的单继承"><a href="#考虑虚函数的单继承" class="headerlink" title="考虑虚函数的单继承"></a>考虑虚函数的单继承</h3><p>如果父类中，出现虚函数，子类中也出现虚函数，会是怎样的一个结构呢？！比如下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derived</span>:<span class="keyword">public</span> base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> c,d;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在实际的存储中的结构应该是这个样子的： <img src="http://i.imgur.com/mnAVrDA.png"></p>
<h2 id="多继承对象模型"><a href="#多继承对象模型" class="headerlink" title="多继承对象模型"></a>多继承对象模型</h2><p>上面讨论了单继承的对象模型，现在讨论一下多继承的对象模型，比如下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">base2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> c,d;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derived</span>:<span class="keyword">public</span> base1,<span class="keyword">public</span> base2&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> e,ff;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的代码，在类中的布局应该是下面的这样的： <img src="http://i.imgur.com/ZXmsdm4.png"> 在这种继承模式下，每个父类都会有一张自己的虚表，里面包含自己的虚函数，而派生类中自己的虚函数，则是放在第一个虚表中的，如果派生类重写了虚函数，那么会自动替换成派生类的虚函数。</p>
<h2 id="存在虚基类的对象模型"><a href="#存在虚基类的对象模型" class="headerlink" title="存在虚基类的对象模型"></a>存在虚基类的对象模型</h2><p>对象继承中，涉及到虚基类的问题，对象继承链中，虚基类只会保存一个实例。如下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">base1</span>:<span class="keyword">public</span> <span class="keyword">virtual</span> base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> c,d;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">base2</span>：<span class="keyword">public</span> <span class="keyword">virtual</span> base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> e,ff;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derived</span>:<span class="keyword">public</span> base1,<span class="keyword">public</span> base2&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> g,h;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这份代码在实际的对象继承中应该是这个样子的布局： <img src="http://i.imgur.com/P5WybyU.png"> 可以发现虚继承过来的基类并不像之前那样放在最上面，而且其实是放在最下面的（事实上，在g++中，表中地址从上而下是变大的）,而每一个虚表都是指向的自己的虚函数，在继承类中，如果重写了这个虚函数函数，对应的虚表中的函数也是会被改成继承类中的虚函数的。 // &lt;![CDATA[ if (typeof MathJaxListener !== ‘undefined’) { MathJax.Hub.Register.StartupHook(‘End’, function () { MathJaxListener.invokeCallbackForKey_(‘End’); }); } // ]]&gt;</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>goolge无法读取此站点地图</title>
    <url>/2025/04/24/goolge%E6%97%A0%E6%B3%95%E8%AF%BB%E5%8F%96%E6%AD%A4%E7%AB%99%E7%82%B9%E5%9C%B0%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="省流结论"><a href="#省流结论" class="headerlink" title="省流结论"></a>省流结论</h2><p>sitemap.xml 能够正常访问，且格式内容没问题的情况下， 提交地址的时候尝试在sitemap.xml后面加”/“， 比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://xtestw.com/sitemap.xml</span><br></pre></td></tr></table></figure>
<p>变为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://xtestw.com/sitemap.xml/</span><br></pre></td></tr></table></figure>


<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>google search console 提交了站点，始终提示 “无法抓取”，点击进去之后显示 “无法读取此站点地图<br>“，但是直接访问sitemap是可以的，网站验证也没问题， 后面找了一圈 就是上面那个结论</p>
<h2 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h2><p>一个测试网站：<a href="https://search.google.com/test/rich-results">富媒体搜索结果测试 - Google Search Console</a></p>
<p>如果你的网站不能通过测试，那么自然无法爬取。我在添加了robots.txt后就，谷歌搜索就可以正常爬取我的博客了。</p>
<p>以及这个网站可以查看谷歌爬虫的情况：<a href="https://search.google.com/search-console/not-verified?original_url=/search-console/settings/crawl-stats?utm_source=wmx&utm_medium=deprecation-pane&utm_content=crawl-stats&original_resource_id">Search Console - Crawl Stats</a></p>
]]></content>
      <categories>
        <category>疑难杂症</category>
      </categories>
  </entry>
  <entry>
    <title>hibernate ID 生成方式</title>
    <url>/2015/02/10/hibernate%20ID%20%E7%94%9F%E6%88%90%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="1、assigned"><a href="#1、assigned" class="headerlink" title="1、assigned"></a>1、assigned</h1><p>主键由外部程序负责生成，在 save() 之前必须指定一个。Hibernate不负责维护主键生成。与Hibernate和底层数据库都无关，可以跨数据库。在存储对象前，必须要使用主键的setter方法给主键赋值，至于这个值怎么生成，完全由自己决定，这种方法应该尽量避免。</p>
<p><strong><id name="id" column="id"></strong></p>
<p><strong><generator class="assigned" /></strong></p>
<p><strong></id></strong></p>
<p>“ud”是自定义的策略名，人为起的名字，后面均用“ud”表示。</p>
<p><strong>特点：可以跨数据库，人为控制主键生成，应尽量避免。</strong></p>
<h1 id="2、increment"><a href="#2、increment" class="headerlink" title="2、increment"></a>2、increment</h1><p>由Hibernate从数据库中取出主键的最大值（每个session只取1次），以该值为基础，每次增量为1，在内存中生成主键，不依赖于底层的数据库，因此可以跨数据库。</p>
<p><strong><id name="id" column="id"></strong></p>
<p><strong><generator class="increment" /></strong></p>
<p><strong></id></strong></p>
<p>Hibernate调用org.hibernate.id.IncrementGenerator类里面的generate()方法，使用select max(idColumnName) from tableName语句获取主键最大值。该方法被声明成了synchronized，所以在一个独立的Java虚拟机内部是没有问题的，然而，在多个JVM同时并发访问数据库select max时就可能取出相同的值，再insert就会发生Dumplicate entry的错误。所以只能有一个Hibernate应用进程访问数据库，否则就可能产生主键冲突，所以不适合多进程并发更新数据库，适合单一进程访问数据库，不能用于群集环境。</p>
<span id="more"></span>

<p>官方文档：只有在没有其他进程往同一张表中插入数据时才能使用，在集群下不要使用。</p>
<p><strong>特点：跨数据库，不适合多进程并发更新数据库，适合单一进程访问数据库，不能用于群集环境。</strong></p>
<h1 id="3、hilo"><a href="#3、hilo" class="headerlink" title="3、hilo"></a>3、hilo</h1><p>hilo（高低位方式high low）是hibernate中最常用的一种生成方式，需要一张额外的表保存hi的值。保存hi值的表至少有一条记录（只与第一条记录有关），否则会出现错误。<strong>可以跨数据库。</strong></p>
<p><strong><id name="id" column="id"></strong></p>
<p><strong><generator class="hilo"></strong></p>
<p><strong><param name="table">hibernate_hilo</param></strong></p>
<p><strong><param name="column">next_hi</param></strong></p>
<p><strong><param name="max_lo">100</param></strong></p>
<p><strong></generator></strong></p>
<p><strong></id></strong></p>
<p><strong><param name="table">hibernate_hilo</param></strong> <strong>指定保存hi值的表名</strong></p>
<p><strong><param name="column">next_hi</param></strong> <strong>指定保存hi值的列名</strong></p>
<p><strong><param name="max_lo">100</param></strong> <strong>指定低位的最大值</strong></p>
<p>也可以省略table和column配置，其默认的表为hibernate_unique_key，列为next_hi</p>
<p><strong><id name="id" column="id"></strong></p>
<p><strong><generator class="hilo"></strong></p>
<p><strong><param name="max_lo">100</param></strong></p>
<p><strong></generator></strong></p>
<p><strong></id></strong></p>
<p>hilo生成器生成主键的过程（以hibernate_unique_key表，next_hi列为例）：</p>
<ol>
<li><p>获得hi值：读取并记录数据库的hibernate_unique_key表中next_hi字段的值，数据库中此字段值加1保存。</p>
</li>
<li><p>获得lo值：从0到max_lo循环取值，差值为1，当值为max_lo值时，重新获取hi值，然后lo值继续从0到max_lo循环。</p>
</li>
<li><p>根据公式 hi * (max_lo + 1) + lo计算生成主键值。</p>
</li>
</ol>
<p>注意：当hi值是0的时候，那么第一个值不是0*(max_lo+1)+0=0，而是lo跳过0从1开始，直接是1、2、3……</p>
<p>那max_lo配置多大合适呢？</p>
<p>这要根据具体情况而定，如果系统一般不重启，而且需要用此表建立大量的主键，可以吧max_lo配置大一点，这样可以减少读取数据表的次数，提高效率；反之，如果服务器经常重启，可以吧max_lo配置小一点，可以避免每次重启主键之间的间隔太大，造成主键值主键不连贯。</p>
<p><strong>特点：跨数据库，hilo算法生成的标志只能在一个数据库中保证唯一。</strong></p>
<h1 id="4、seqhilo"><a href="#4、seqhilo" class="headerlink" title="4、seqhilo"></a>4、seqhilo</h1><p>与hilo类似，通过hi/lo算法实现的主键生成机制，只是将hilo中的数据表换成了序列sequence，需要数据库中先创建sequence，适用于支持sequence的数据库，如Oracle。</p>
<p><strong><id name="id" column="id"></strong></p>
<p><strong><generator class="seqhilo"></strong></p>
<p><strong><param name="sequence">hibernate_seq</param></strong></p>
<p><strong><param name="max_lo">100</param></strong></p>
<p><strong></generator></strong></p>
<p><strong></id></strong></p>
<p><strong>特点：与hilo类似，只能在支持序列的数据库中使用。</strong></p>
<h1 id="5、sequence"><a href="#5、sequence" class="headerlink" title="5、sequence"></a>5、sequence</h1><p>采用数据库提供的sequence机制生成主键，需要数据库支持sequence。如oralce、DB、SAP DB、PostgerSQL、McKoi中的sequence。MySQL这种不支持sequence的数据库则不行（可以使用identity）。</p>
<p><strong><generator class="sequence"></strong></p>
<p><strong><param name="sequence">hibernate_id</param></strong></p>
<p><strong></generator></strong></p>
<p><strong><param name="sequence">hibernate_id</param></strong> <strong>指定sequence的名称</strong></p>
<p>Hibernate生成主键时，查找sequence并赋给主键值，主键值由数据库生成，Hibernate不负责维护，使用时必须先创建一个sequence，如果不指定sequence名称，则使用Hibernate默认的sequence，名称为hibernate_sequence，前提要在数据库中创建该sequence。</p>
<p><strong>特点：只能在支持序列的数据库中使用，如Oracle。</strong></p>
<h1 id="6、identity"><a href="#6、identity" class="headerlink" title="6、identity"></a>6、identity</h1><p>identity由底层数据库生成标识符。identity是由数据库自己生成的，但这个主键必须设置为自增长，使用identity的前提条件是底层数据库支持自动增长字段类型，如DB2、SQL Server、MySQL、Sybase和HypersonicSQL等，Oracle这类没有自增字段的则不支持。</p>
<p><strong><id name="id" column="id"></strong></p>
<p><strong><generator class="identity" /></strong></p>
<p><strong></id></strong></p>
<p>例：如果使用MySQL数据库，则主键字段必须设置成auto_increment。</p>
<p>id int(11) primary key auto_increment</p>
<p><strong>特点：只能用在支持自动增长的字段数据库中使用，如MySQL。</strong></p>
<h1 id="7、native"><a href="#7、native" class="headerlink" title="7、native"></a>7、native</h1><p>native由hibernate根据使用的数据库自行判断采用identity、hilo、sequence其中一种作为主键生成方式，灵活性很强。如果能支持identity则使用identity，如果支持sequence则使用sequence。</p>
<p><strong><id name="id" column="id"></strong></p>
<p><strong><generator class="native" /></strong></p>
<p><strong></id></strong></p>
<p>例如MySQL使用identity，Oracle使用sequence</p>
<p>注意：如果Hibernate自动选择sequence或者hilo，则所有的表的主键都会从Hibernate默认的sequence或hilo表中取。并且，有的数据库对于默认情况主键生成测试的支持，效率并不是很高。</p>
<p>使用sequence或hilo时，可以加入参数，指定sequence名称或hi值表名称等，如</p>
<p><strong><param name="sequence">hibernate_id</param></strong></p>
<p><strong>特点：根据数据库自动选择，项目中如果用到多个数据库时，可以使用这种方式，使用时需要设置表的自增字段或建立序列，建立表等。</strong></p>
<h1 id="8、uuid"><a href="#8、uuid" class="headerlink" title="8、uuid"></a>8、uuid</h1><p>UUID：Universally Unique Identifier，是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字，标准的UUID格式为：</p>
<p><strong>xxxxxxxx-xxxx-xxxx-xxxxxx-xxxxxxxxxx (8-4-4-4-12)</strong></p>
<p>其中每个 <strong>x</strong> 是 0-9 或 a-f 范围内的一个十六进制的数字。</p>
<p><strong><id name="id" column="id"></strong></p>
<p><strong><generator class="uuid" /></strong></p>
<p><strong></id></strong></p>
<p>Hibernate在保存对象时，生成一个UUID字符串作为主键，保证了唯一性，但其并无任何业务逻辑意义，只能作为主键，唯一缺点长度较大，32位（Hibernate将UUID中间的“-”删除了）的字符串，占用存储空间大，但是有两个很重要的优点，Hibernate在维护主键时，不用去数据库查询，从而提高效率，而且它是跨数据库的，以后切换数据库极其方便。</p>
<p><strong>特点：uuid长度大，占用空间大，跨数据库，不用访问数据库就生成主键值，所以效率高且能保证唯一性，移植非常方便，推荐使用。</strong></p>
<h1 id="9、guid"><a href="#9、guid" class="headerlink" title="9、guid"></a>9、guid</h1><p>GUID：Globally Unique Identifier全球唯一标识符，也称作 UUID，是一个128位长的数字，用16进制表示。算法的核心思想是结合机器的网卡、当地时间、一个随即数来生成GUID。从理论上讲，如果一台机器每秒产生10000000个GUID，则可以保证（概率意义上）3240年不重复。</p>
<p><strong><id name="id" column="id"></strong></p>
<p><strong><generator class="guid" /></strong></p>
<p><strong></id></strong></p>
<p>Hibernate在维护主键时，先查询数据库，获得一个uuid字符串，该字符串就是主键值，该值唯一，缺点长度较大，支持数据库有限，优点同uuid，跨数据库，但是仍然需要访问数据库。</p>
<p><strong>注意：长度因数据库不同而不同</strong></p>
<p>MySQL中使用select uuid()语句获得的为36位（包含标准格式的“-”）</p>
<p>Oracle中，使用select rawtohex(sys_guid()) from dual语句获得的为32位（不包含“-”） </p>
<p><strong>特点：需要数据库支持查询uuid，生成时需要查询数据库，效率没有uuid高，推荐使用uuid。</strong></p>
<h1 id="10、foreign"><a href="#10、foreign" class="headerlink" title="10、foreign"></a>10、foreign</h1><p>使用另外一个相关联的对象的主键作为该对象主键。主要用于一对一关系中。</p>
<p><strong><id name="id" column="id"></strong></p>
<p><strong><generator class="foreign"></strong></p>
<p><strong><param name="property">user</param></strong></p>
<p><strong></generator></strong></p>
<p><strong></id></strong></p>
<p><strong><one-to-one name="user" class="domain.User" constrained="true" /></strong></p>
<p>该例使用domain.User的主键作为本类映射的主键。</p>
<p><strong>特点：很少使用，大多用在一对一关系中。</strong></p>
<h1 id="11、select"><a href="#11、select" class="headerlink" title="11、select"></a>11、select</h1><p>使用触发器生成主键，主要用于早期的数据库主键生成机制，能用到的地方非常少。</p>
<h1 id="12、其他注释方式配置"><a href="#12、其他注释方式配置" class="headerlink" title="12、其他注释方式配置"></a>12、其他注释方式配置</h1><p>注释方式与配置文件底层实现方式相同，只是配置的方式换成了注释方式</p>
<p>自动增长，适用于支持自增字段的数据库</p>
<p><strong>@Id</strong></p>
<p><strong>@GeneratedValue(strategy = GenerationType.IDENTITY)</strong></p>
<p>根据底层数据库自动选择方式，需要底层数据库的设置</p>
<p>如MySQL，会使用自增字段，需要将主键设置成auto_increment。</p>
<p><strong>@Id</strong></p>
<p><strong>@GeneratedValue(strategy = GenerationType.AUTO)</strong></p>
<p>使用表存储生成的主键，可以跨数据库。</p>
<p>每次需要主键值时，查询名为**”hibernate_table”<strong>的表，查找主键列</strong>“gen_pk”<strong>值为</strong>“2”<strong>记录，得到这条记录的</strong>“gen_val”<strong>值，根据这个值，和</strong>allocationSize**的值生成主键值。</p>
<p><strong>@Id</strong></p>
<p><strong>@GeneratedValue(strategy = GenerationType.TABLE, generator = “ud”)</strong></p>
<p><strong>@TableGenerator(name = “ud”,</strong></p>
<p><strong>table = “hibernate_table”,</strong></p>
<p><strong>pkColumnName = “gen_pk”,</strong></p>
<p><strong>pkColumnValue = “2”,</strong></p>
<p><strong>valueColumnName = “gen_val”,</strong></p>
<p><strong>initialValue = 2,</strong></p>
<p><strong>allocationSize = 5)</strong></p>
<p>使用序列存储主键值</p>
<p><strong>@Id</strong></p>
<p><strong>@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = “ud”)</strong></p>
<p><strong>@SequenceGenerator(name = “ud”,</strong></p>
<p><strong>sequenceName = “hibernate_seq”,</strong></p>
<p><strong>allocationSize = 1,</strong></p>
<p><strong>initialValue = 2)</strong></p>
<h1 id="13、小结"><a href="#13、小结" class="headerlink" title="13、小结"></a>13、小结</h1><p><strong>1****、为了保证对象标识符的唯一性与不可变性，应该让Hibernate来为主键赋值，而不是程序。</strong></p>
<p><strong>2****、正常使用Hibernate维护主键，最好将主键的setter方法设置成private，从而避免人为或程序修改主键，而使用assigned方式，就不能用private，否则无法给主键赋值。</strong></p>
<p><strong>2、Hibernate中唯一一种最简单通用的主键生成器就是uuid。虽然是个32位难读的长字符串，但是它没有跨数据库的问题，将来切换数据库极其简单方便，推荐使用！</strong></p>
<p><strong>3、自动增长字段类型与序列</strong></p>
<table>
<thead>
<tr>
<th><strong>数据库</strong></th>
<th><strong>自动增长字段</strong></th>
<th><strong>序列</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>MySQL</strong></td>
<td><strong>是</strong></td>
<td></td>
</tr>
<tr>
<td><strong>Oracle</strong></td>
<td></td>
<td><strong>是</strong></td>
</tr>
<tr>
<td><strong>DB2</strong></td>
<td><strong>是</strong></td>
<td><strong>是</strong></td>
</tr>
<tr>
<td><strong>MS SQL Server</strong></td>
<td><strong>是</strong></td>
<td></td>
</tr>
<tr>
<td><strong>Sybase</strong></td>
<td><strong>是</strong></td>
<td></td>
</tr>
<tr>
<td><strong>HypersonicSQL</strong></td>
<td><strong>是</strong></td>
<td></td>
</tr>
<tr>
<td><strong>PostgreSQL</strong></td>
<td></td>
<td><strong>是</strong></td>
</tr>
<tr>
<td><strong>SAP DB</strong></td>
<td></td>
<td><strong>是</strong></td>
</tr>
<tr>
<td><strong>HSQLDB</strong></td>
<td><strong>是</strong></td>
<td></td>
</tr>
<tr>
<td><strong>Infomix</strong></td>
<td><strong>是</strong></td>
<td></td>
</tr>
</tbody></table>
<p><strong>4、关于hilo机制注意：</strong></p>
<p><strong>hilo算法生成的标志只能在一个数据库中保证唯一。</strong></p>
<p><strong>当用户为Hibernate自行提供连接，或者Hibernate通过JTA，从应用服务器的数据源获取数据库连接时，无法使用hilo，因为这不能保证hilo单独在新的数据库连接的事务中访问hi值表，这种情况，如果数据库支持序列，可以使用seqhilo。</strong></p>
<p><strong>5、使用identity、native、GenerationType.AUTO等方式生成主键时，只要用到自增字段，数据库表的字段必须设置成自动增加的，否则出错。</strong></p>
<p><strong>6、还有一些方法未列出来，例如uuid.hex，sequence-identity等，这些方法不是很常用，且已被其他方法代替，如uuid.hex，官方文档里建议不使用，而直接使用uuid方法。</strong></p>
<p><strong>7、Hibernate的各版本主键生成策略配置有略微差别，但实现基本相同。如，有的版本默认sequence不指定序列名，则使用名为hibernate_sequence的序列，有的版本则必须指定序列名。</strong></p>
<p><strong>8、还可以自定义主键生成策略，这里暂时不讨论，只讨论官方自带生成策略。</strong></p>
<p>转自：<a href="http://www.cnblogs.com/kakafra/archive/2012/09/16/2687569.html">http://www.cnblogs.com/kakafra/archive/2012/09/16/2687569.html</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>IOCP</title>
    <url>/2015/01/29/iocp/</url>
    <content><![CDATA[<p>IOCP是windows下的一种异步IO通信模式（linux下面对应epoll，二者有区别—&gt;<a href="http://www.cnblogs.com/uzhang/archive/2012/02/24/2365980.html%EF%BC%89">http://www.cnblogs.com/uzhang/archive/2012/02/24/2365980.html）</a></p>
<p>一样的socket的绑定通信的过程，不同的是并不对每一个用户请求单独开设一个线程去处理用户请求，而是在后面一线程池的方式，开固定的线程，轮流处理用户请求，减少线程的上下文切换损耗，同时利用重叠IO，减低内存等资源的消耗。 关于具体的一些内容，见：<a href="http://blog.csdn.net/neicole/article/details/7549497">http://blog.csdn.net/neicole/article/details/7549497</a></p>
]]></content>
      <categories>
        <category>Theory</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm的一些参数说明</title>
    <url>/2025/05/06/jvm%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h2 id="ReservedCodeCacheSize"><a href="#ReservedCodeCacheSize" class="headerlink" title="ReservedCodeCacheSize"></a>ReservedCodeCacheSize</h2><p>ReservedCodeCacheSize 参数主要用于设置 Java 虚拟机（JVM）中用于存储已编译的本地方法和JIT编译后的代码的缓存大小。这个参数对于运行大量需要即时编译的代码的应用程序尤其重要，比如大型的Java应用或者使用了大量动态代理、反射等技术的应用。<br>当 JVM 启动时，会预留一块内存区域作为 Code Cache 来存放这些编译后的代码。如果 Code Cache 的空间不足，可能会导致编译器停止编译新的代码，转而使用解释执行的方式，这会影响应用程序的性能。通过调整 ReservedCodeCacheSize 的值，可以确保有足够的空间来存储更多的编译代码，从而提高应用的运行效率。<br>通常，如果你的应用程序在运行过程中遇到了“CodeCache is full”的错误信息，可能就需要考虑增加 ReservedCodeCacheSize 的值了。可以通过启动参数 -XX:ReservedCodeCacheSize=<size> 来设置这个值，其中 <size> 是你希望分配给 Code Cache 的内存大小，例如 -XX:ReservedCodeCacheSize=256m 表示设置 Code Cache 的大小为 256MB。</p>
<h2 id="java-locale-useOldISOCodes"><a href="#java-locale-useOldISOCodes" class="headerlink" title="java.locale.useOldISOCodes"></a>java.locale.useOldISOCodes</h2><p>用于控制 Java 虚拟机（JVM）在处理某些国家/地区代码时是否使用旧的 ISO 3166-1 标准。这个属性主要影响 Locale 类的行为，特别是在解析和生成国家/地区的 ISO 代码时。</p>
<h4 id="新旧标准的区别"><a href="#新旧标准的区别" class="headerlink" title="新旧标准的区别"></a>新旧标准的区别</h4><ul>
<li>国家/地区代码的变化：<ul>
<li>旧标准：早期版本的 ISO 3166-1 包含了一些已经不再存在的国家或地区的代码。</li>
<li>新标准：更新后的 ISO 3166-1 标准删除了不再使用的代码，并添加了新的国家或地区的代码。</li>
</ul>
</li>
<li>代码的标准化：<ul>
<li>旧标准：早期版本可能包含一些不一致或非标准的代码。</li>
<li>新标准：更新后的标准更加规范，确保每个国家或地区都有唯一且明确的代码。</li>
</ul>
</li>
</ul>
<h2 id="java-locale-useOldISOCodes-1"><a href="#java-locale-useOldISOCodes-1" class="headerlink" title="java.locale.useOldISOCodes"></a>java.locale.useOldISOCodes</h2><p>用于控制 Java 虚拟机（JVM）在处理某些国家/地区代码时是否使用旧的 ISO 3166-1 标准。这个属性主要影响 Locale 类的行为，特别是在解析和生成国家/地区的 ISO 代码时。<br>新旧标准的区别</p>
<ul>
<li>国家/地区代码的变化：<ul>
<li>旧标准：早期版本的 ISO 3166-1 包含了一些已经不再存在的国家或地区的代码。</li>
<li>新标准：更新后的 ISO 3166-1 标准删除了不再使用的代码，并添加了新的国家或地区的代码。</li>
</ul>
</li>
</ul>
<h2 id="UnlockExperimentalVMOptions"><a href="#UnlockExperimentalVMOptions" class="headerlink" title="UnlockExperimentalVMOptions"></a>UnlockExperimentalVMOptions</h2><p>用于解锁实验性的虚拟机选项。这些选项通常是未公开的、正在测试中的或不稳定的特性，因此默认情况下是不可用的。通过使用 UnlockExperimentalVMOptions，你可以启用这些实验性选项，以便在特定场景下进行测试和调试。</p>
<h4 id="主要用途"><a href="#主要用途" class="headerlink" title="主要用途"></a>主要用途</h4><ul>
<li>启用实验性功能：<ul>
<li>访问和测试 JVM 开发团队正在研究的新功能。</li>
<li>调试和诊断 JVM 的内部行为。</li>
</ul>
</li>
<li>性能优化：<ul>
<li>测试新的垃圾回收算法或其他性能相关的实验性选项。</li>
</ul>
</li>
</ul>
<h2 id="UseWisp2"><a href="#UseWisp2" class="headerlink" title="UseWisp2"></a>UseWisp2</h2><p>用于启用 Wisp2 编译器。Wisp2 是 Oracle 在 JDK 17 中引入的一个新的即时编译器（JIT 编译器），旨在提高编译性能和优化代码生成。Wisp2 仍然是一个实验性的特性，因此默认情况下是禁用的。要启用 Wisp2，你需要使用 UnlockExperimentalVMOptions 和 UseWisp2 选项。</p>
<h4 id="主要用途-1"><a href="#主要用途-1" class="headerlink" title="主要用途"></a>主要用途</h4><ul>
<li>提高编译性能：<ul>
<li>Wisp2 编译器旨在更快地编译热点代码，从而提高应用程序的启动时间和运行性能。</li>
</ul>
</li>
<li>优化代码生成：<ul>
<li>Wisp2 生成的代码可能比现有的 C1 和 C2 编译器更高效，尤其是在处理复杂和高性能计算时。</li>
</ul>
</li>
</ul>
<h2 id="io-netty-transport-noNative"><a href="#io-netty-transport-noNative" class="headerlink" title="io.netty.transport.noNative"></a>io.netty.transport.noNative</h2><p>用于控制 Netty 是否使用原生传输（Native Transport）。Netty 是一个高性能的网络编程框架，广泛用于构建各种网络应用，包括 HTTP 服务器、RPC 框架等。原生传输通常指的是使用操作系统提供的高性能网络传输机制，例如 Epoll（Linux）或 KQueue（FreeBSD 和 macOS）。</p>
<h4 id="主要用途-2"><a href="#主要用途-2" class="headerlink" title="主要用途"></a>主要用途</h4><ul>
<li>性能优化：<ul>
<li>原生传输通常比纯 Java 实现的 NIO 更高效，因为它直接利用操作系统的内核功能，减少了用户态和内核态之间的切换开销。</li>
</ul>
</li>
<li>兼容性：<ul>
<li>有些操作系统或环境可能不支持原生传输，或者你可能希望在某些情况下禁用原生传输以进行调试或测试。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>零碎知识</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>ReservedCodeCacheSize</tag>
      </tags>
  </entry>
  <entry>
    <title>java内省机制</title>
    <url>/2025/05/13/java%E5%86%85%E7%9C%81%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<blockquote>
<p>At runtime and in the builder environment we need to be able to figure out which properties, events, and methods a Java Bean supports. We call this process introspection.</p>
</blockquote>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之所以要了解这个概念，是修改了pom之后，线上出现了 <code> Post-processing of merged bean definition failed; nested exception is java.lang.IllegalStateException: Failed to introspect Class</code> 的错误，其实本身就是因为spring尝试分析bean属性时发生的错误，大概率是依赖找不到，后面也是在后续的日志里发现了 ClassNotFound 的错误。</p>
<h2 id="什么是内省机制"><a href="#什么是内省机制" class="headerlink" title="什么是内省机制"></a>什么是内省机制</h2><p>计算机程序在运行时(Runtime)检查对象(Object)类型的一种能力, 通常也可以称作运行时类型检查。<br>简单来说，可以用反射来理解，就是运行时能够动态的获取java bean的相关属性</p>
<h2 id="java-内省机制的实现"><a href="#java-内省机制的实现" class="headerlink" title="java 内省机制的实现"></a>java 内省机制的实现</h2><p>java 提供了一套 api 来允许程序运行时获取对象的信息和实例的信息。 这些类在 <code>java.beans</code> 中，核心的类是 <code>Introspector</code>。 本质上是反射的一层封装。</p>
<h2 id="spring-中-内省机制的应用"><a href="#spring-中-内省机制的应用" class="headerlink" title="spring 中 内省机制的应用"></a>spring 中 内省机制的应用</h2>]]></content>
      <categories>
        <category>零碎知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>内省</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka重复消费？</title>
    <url>/2025/04/29/kafka%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="问题阐述"><a href="#问题阐述" class="headerlink" title="问题阐述"></a>问题阐述</h2><p>有个业务场景，是通过kafka给审核中台推审核任务，链路是 离线获取待审核直播间 -&gt; 推送kafka -&gt; 业务消费kafka做物料整理 -&gt; 通过kafka 推到审核中台审核。</p>
<p>问题的现象是： 离线待审核直播间只有几百个的时候， 审核中台收到了几千个直播间，经检查明显是重复推送了。</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><ul>
<li>检查业务代码逻辑，不存在重复推送的情况</li>
<li>相关监控 验证了 确实没有单次消费，多次推送的情况</li>
<li>查看kafka相关监控，发现offset 一只没有变化， 且 lag 很高</li>
<li>继续观察相关监控 发现 持续rebalance</li>
<li>初步怀疑是 rebalance 导致kafka 重复消费</li>
</ul>
<h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><ul>
<li>由于审核材料会调用AI进行预处理，有频控问题，所以整体消费速度很慢</li>
<li>由于消费速度慢，因此在hive2kafka的过程中限制了生产速度 1条/s</li>
<li>由于前两者，导致kafka 执行速度非常慢，中台配置单次pull 执行超过了5min，就会自动rebalance</li>
</ul>
]]></content>
      <categories>
        <category>疑难杂症</category>
      </categories>
      <tags>
        <tag>kafka</tag>
        <tag>QA</tag>
      </tags>
  </entry>
  <entry>
    <title>kruskal 算法</title>
    <url>/2013/04/29/kruskal-e7-ae-97-e6-b3-95/</url>
    <content><![CDATA[<p>kruskal算法的主要思想就是从当前路径中选择一个不能构成环的最小边加入</p>
<p>for (int i=1;i&lt;n;i++)<br>    {<br>        int mi=1000000,k;<br>        for (int j=0;j&lt;m;j++)<br>        {<br>            if ((v[e[j].x] + v[e[j].y]==1 || i==1 ) &amp;&amp; e[j].d&lt;mi){ mi=e[j].d; k=j; } } result.push_back(k); v[e[k].x]=1; v[e[k].y]=1; if (mi&gt;ma) ma=mi;<br>    }</p>
<p>因为此算法本质上是一个贪心策略，可以通过并查集进行优化，现将其从小到大排序</p>
<p>int kruskal()//返回最小生成树的和<br>{<br>    int ans=0;<br>    qsort(e,e+n,cmp);//cmp是将其按d值从小到大排序<br>    for (int i=0;i&lt;m;i++)//m is the number of edges<br>    {<br>        if (find(e[i].x)!=find(e[i].y)) {//判断边的两个端点是否在一个集合<br>             result.push_back(i);<br>             ans+=e[i].d;<br>        }<br>    }<br>    return ans;<br>}</p>
<p>poj 1861</p>
<p>#include<br>#include<br>#include<br>#include<br>using namespace std;<br>struct P{<br>    int x,y,d;<br>};<br>P e[15100];<br>vector result;<br>int ma=-1;<br>int v[1002]={0};<br>int main()<br>{<br>    int n,m;<br>    scanf(“%d%d”,&amp;n,&amp;m);<br>    for (int i=0;i&lt;m;i++)<br>        scanf(“%d%d%d”,&amp;e[i].x,&amp;e[i].y,&amp;e[i].d);<br>    for (int i=1;i&lt;n;i++)<br>    {<br>        int mi=1000000,k;<br>        for (int j=0;j&lt;m;j++)<br>        {<br>            if ((v[e[j].x] + v[e[j].y]==1 || i==1 ) &amp;&amp; e[j].d&lt;mi){                 mi=e[j].d;                 k=j;             }         }         result.push_back(k);         v[e[k].x]=1;         v[e[k].y]=1;         if (mi&gt;ma) ma=mi;<br>    }<br>    cout&lt;&lt;ma&lt;&lt;endl;<br>    cout&lt;&lt;result.size()&lt;&lt;endl;<br>    for (int i=0;i&lt;result.size();i++)<br>    {<br>        cout&lt;&lt;e[result[i]].x&lt;&lt; “ “&lt;&lt;e[result[i]].y&lt;&lt;endl;<br>    }<br>    return 0;<br>}</p>
]]></content>
      <categories>
        <category>ACMICPC</category>
      </categories>
      <tags>
        <tag>prof,acm</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 技巧：让进程在后台可靠运行的几种方法</title>
    <url>/2016/01/29/linuxrunonbackground/</url>
    <content><![CDATA[<p>转自：<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-nohup/">http://www.ibm.com/developerworks/cn/linux/l-cn-nohup/</a> 我们经常会碰到这样的问题，用 telnet/ssh 登录了远程的 Linux 服务器，运行了一些耗时较长的任务， 结果却由于网络的不稳定导致任务中途失败。如何让命令提交后不受本地关闭终端窗口/网络断开连接的干扰呢？下面举了一些例子， 您可以针对不同的场景选择不同的方式来处理这个问题。</p>
<h2 id="nohup-setsid-amp"><a href="#nohup-setsid-amp" class="headerlink" title="nohup/setsid/&amp;"></a>nohup/setsid/&amp;</h2><h4 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h4><p>如果只是临时有一个命令需要长时间运行，什么方法能最简便的保证它在后台稳定运行呢？</p>
<blockquote>
<h5 id="hangup-名称的来由"><a href="#hangup-名称的来由" class="headerlink" title="hangup 名称的来由"></a>hangup 名称的来由</h5><p>在 Unix 的早期版本中，每个终端都会通过 modem 和系统通讯。当用户 logout 时，modem 就会挂断（hang up）电话。 同理，当 modem 断开连接时，就会给终端发送 hangup 信号来通知其关闭所有子进程。</p>
</blockquote>
<span id="more"></span>

<h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><p>我们知道，当用户注销（logout）或者网络断开时，终端会收到 HUP（hangup）信号从而关闭其所有子进程。因此，我们的解决办法就有两种途径：要么让进程忽略 HUP 信号，要么让进程运行在新的会话里从而成为不属于此终端的子进程。</p>
<h3 id="1-nohup"><a href="#1-nohup" class="headerlink" title="1. nohup"></a>1. nohup</h3><p>nohup 无疑是我们首先想到的办法。顾名思义，nohup 的用途就是让提交的命令忽略 hangup 信号。让我们先来看一下 nohup 的帮助信息： NOHUP(1) User Commands NOHUP(1)</p>
<pre><code>NAME
       nohup - run a command immune to hangups, with output to a non-tty

SYNOPSIS
       nohup COMMAND [ARG]...
       nohup OPTION

DESCRIPTION
       Run COMMAND, ignoring hangup signals.

       --help display this help and exit

       --version
              output version information and exit
</code></pre>
<p>可见，nohup 的使用是十分方便的，只需在要处理的命令前加上 nohup 即可，标准输出和标准错误缺省会被重定向到 nohup.out 文件中。一般我们可在结尾加上&amp;来将命令同时放入后台运行，也可用&gt;filename 2&gt;&amp;1来更改缺省的重定向文件名。</p>
<h5 id="nohup-示例"><a href="#nohup-示例" class="headerlink" title="nohup 示例"></a>nohup 示例</h5><pre><code>[root@pvcent107 ~]# nohup ping www.ibm.com &amp;
[1] 3059
nohup: appending output to `nohup.out&#39;
[root@pvcent107 ~]# ps -ef |grep 3059
root      3059   984  0 21:06 pts/3    00:00:00 ping www.ibm.com
root      3067   984  0 21:06 pts/3    00:00:00 grep 3059
[root@pvcent107 ~]#
</code></pre>
<h3 id="2-setsid"><a href="#2-setsid" class="headerlink" title="2.setsid"></a>2.setsid</h3><p>nohup 无疑能通过忽略 HUP 信号来使我们的进程避免中途被中断，但如果我们换个角度思考，如果我们的进程不属于接受 HUP 信号的终端的子进程，那么自然也就不会受到 HUP 信号的影响了。setsid 就能帮助我们做到这一点。让我们先来看一下 setsid 的帮助信息： SETSID(8) Linux Programmer’s Manual SETSID(8)</p>
<pre><code>NAME
       setsid - run a program in a new session

SYNOPSIS
       setsid program [ arg ... ]

DESCRIPTION
       setsid runs a program in a new session.
</code></pre>
<p>可见 setsid 的使用也是非常方便的，也只需在要处理的命令前加上 setsid 即可。</p>
<h5 id="setsid-示例"><a href="#setsid-示例" class="headerlink" title="setsid 示例"></a>setsid 示例</h5><pre><code>[root@pvcent107 ~]# setsid ping www.ibm.com
[root@pvcent107 ~]# ps -ef |grep www.ibm.com
root     31094     1  0 07:28 ?        00:00:00 ping www.ibm.com
root     31102 29217  0 07:29 pts/4    00:00:00 grep www.ibm.com
[root@pvcent107 ~]#
</code></pre>
<p>值得注意的是，上例中我们的进程 ID(PID)为31094，而它的父 ID（PPID）为1（即为 init 进程 ID），并不是当前终端的进程 ID。请将此例与nohup 例中的父 ID 做比较。</p>
<h3 id="3-amp"><a href="#3-amp" class="headerlink" title="3.&amp;"></a>3.&amp;</h3><p>这里还有一个关于 subshell 的小技巧。我们知道，将一个或多个命名包含在“()”中就能让这些命令在子 shell 中运行中，从而扩展出很多有趣的功能，我们现在要讨论的就是其中之一。 当我们将&amp;也放入“()”内之后，我们就会发现所提交的作业并不在作业列表中，也就是说，是无法通过jobs来查看的。让我们来看看为什么这样就能躲过 HUP 信号的影响吧。</p>
<h5 id="subshell-示例"><a href="#subshell-示例" class="headerlink" title="subshell 示例"></a>subshell 示例</h5><pre><code>[root@pvcent107 ~]# (ping www.ibm.com &amp;)
[root@pvcent107 ~]# ps -ef |grep www.ibm.com
root     16270     1  0 14:13 pts/4    00:00:00 ping www.ibm.com
root     16278 15362  0 14:13 pts/4    00:00:00 grep www.ibm.com
[root@pvcent107 ~]#
</code></pre>
<p>从上例中可以看出，新提交的进程的父 ID（PPID）为1（init 进程的 PID），并不是当前终端的进程 ID。因此并不属于当前终端的子进程，从而也就不会受到当前终端的 HUP 信号的影响了。</p>
<h2 id="disown"><a href="#disown" class="headerlink" title="disown"></a>disown</h2><h4 id="场景：-1"><a href="#场景：-1" class="headerlink" title="场景："></a>场景：</h4><p>我们已经知道，如果事先在命令前加上 nohup 或者 setsid 就可以避免 HUP 信号的影响。但是如果我们未加任何处理就已经提交了命令，该如何补救才能让它避免 HUP 信号的影响呢？</p>
<h4 id="解决方法：-1"><a href="#解决方法：-1" class="headerlink" title="解决方法："></a>解决方法：</h4><p>这时想加 nohup 或者 setsid 已经为时已晚，只能通过作业调度和 disown 来解决这个问题了。让我们来看一下 disown 的帮助信息： disown [-ar] [-h] [jobspec …] Without options, each jobspec is removed from the table of active jobs. If the -h option is given, each jobspec is not removed from the table, but is marked so that SIGHUP is not sent to the job if the shell receives a SIGHUP. If no jobspec is present, and neither the -a nor the -r option is supplied, the current job is used. If no jobspec is supplied, the -a option means to remove or mark all jobs; the -r option without a jobspec argument restricts operation to running jobs. The return value is 0 unless a jobspec does not specify a valid job. 可以看出，我们可以用如下方式来达成我们的目的。</p>
<blockquote>
<h5 id="灵活运用-CTRL-z"><a href="#灵活运用-CTRL-z" class="headerlink" title="灵活运用 CTRL-z"></a>灵活运用 CTRL-z</h5><p>在我们的日常工作中，我们可以用 CTRL-z 来将当前进程挂起到后台暂停运行，执行一些别的操作，然后再用 fg 来将挂起的进程重新放回前台（也可用 bg 来将挂起的进程放在后台）继续运行。这样我们就可以在一个终端内灵活切换运行多个任务，这一点在调试代码时尤为有用。因为将代码编辑器挂起到后台再重新放回时，光标定位仍然停留在上次挂起时的位置，避免了重新定位的麻烦。</p>
</blockquote>
<ul>
<li>  用disown -h jobspec来使某个作业忽略HUP信号。</li>
<li>  用disown -ah 来使所有的作业都忽略HUP信号。</li>
<li>  用disown -rh 来使正在运行的作业忽略HUP信号。</li>
</ul>
<p>需要注意的是，当使用过 disown 之后，会将把目标作业从作业列表中移除，我们将不能再使用jobs来查看它，但是依然能够用ps -ef查找到它。 但是还有一个问题，这种方法的操作对象是作业，如果我们在运行命令时在结尾加了&amp;来使它成为一个作业并在后台运行，那么就万事大吉了，我们可以通过jobs命令来得到所有作业的列表。但是如果并没有把当前命令作为作业来运行，如何才能得到它的作业号呢？答案就是用 CTRL-z（按住Ctrl键的同时按住z键）了！ CTRL-z 的用途就是将当前进程挂起（Suspend），然后我们就可以用jobs命令来查询它的作业号，再用bg jobspec来将它放入后台并继续运行。需要注意的是，如果挂起会影响当前进程的运行结果，请慎用此方法。</p>
<h5 id="disown-示例1（如果提交命令时已经用“-amp-”将命令放入后台运行，则可以直接使用“disown”）"><a href="#disown-示例1（如果提交命令时已经用“-amp-”将命令放入后台运行，则可以直接使用“disown”）" class="headerlink" title="disown 示例1（如果提交命令时已经用“&amp;”将命令放入后台运行，则可以直接使用“disown”）"></a>disown 示例1（如果提交命令时已经用“&amp;”将命令放入后台运行，则可以直接使用“disown”）</h5><pre><code>[root@pvcent107 build]# cp -r testLargeFile largeFile &amp;
[1] 4825
[root@pvcent107 build]# jobs
[1]+  Running                 cp -i -r testLargeFile largeFile &amp;
[root@pvcent107 build]# disown -h %1
[root@pvcent107 build]# ps -ef |grep largeFile
root      4825   968  1 09:46 pts/4    00:00:00 cp -i -r testLargeFile largeFile
root      4853   968  0 09:46 pts/4    00:00:00 grep largeFile
[root@pvcent107 build]# logout
</code></pre>
<h5 id="disown-示例2（如果提交命令时未使用“-amp-”将命令放入后台运行，可使用-CTRL-z-和“bg”将其放入后台，再使用“disown”）"><a href="#disown-示例2（如果提交命令时未使用“-amp-”将命令放入后台运行，可使用-CTRL-z-和“bg”将其放入后台，再使用“disown”）" class="headerlink" title="disown 示例2（如果提交命令时未使用“&amp;”将命令放入后台运行，可使用 CTRL-z 和“bg”将其放入后台，再使用“disown”）"></a>disown 示例2（如果提交命令时未使用“&amp;”将命令放入后台运行，可使用 CTRL-z 和“bg”将其放入后台，再使用“disown”）</h5><pre><code>[root@pvcent107 build]# cp -r testLargeFile largeFile2

[1]+  Stopped                 cp -i -r testLargeFile largeFile2
[root@pvcent107 build]# bg %1
[1]+ cp -i -r testLargeFile largeFile2 &amp;
[root@pvcent107 build]# jobs
[1]+  Running                 cp -i -r testLargeFile largeFile2 &amp;
[root@pvcent107 build]# disown -h %1
[root@pvcent107 build]# ps -ef |grep largeFile2
root      5790  5577  1 10:04 pts/3    00:00:00 cp -i -r testLargeFile largeFile2
root      5824  5577  0 10:05 pts/3    00:00:00 grep largeFile2
[root@pvcent107 build]#
</code></pre>
<h2 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h2><h4 id="场景：-2"><a href="#场景：-2" class="headerlink" title="场景："></a>场景：</h4><p>我们已经知道了如何让进程免受 HUP 信号的影响，但是如果有大量这种命令需要在稳定的后台里运行，如何避免对每条命令都做这样的操作呢？</p>
<h4 id="解决方法：-2"><a href="#解决方法：-2" class="headerlink" title="解决方法："></a>解决方法：</h4><pre><code>此时最方便的方法就是 screen 了。简单的说，screen 提供了 ANSI/VT100 的终端模拟器，使它能够在一个真实终端下运行多个全屏的伪终端。screen 的参数很多，具有很强大的功能，我们在此仅介绍其常用功能以及简要分析一下为什么使用 screen 能够避免 HUP 信号的影响。我们先看一下 screen 的帮助信息：                                                   SCREEN(1)

NAME
       screen - screen manager with VT100/ANSI terminal emulation

SYNOPSIS
       screen [ -options ] [ cmd [ args ] ]
       screen -r [[pid.]tty[.host]]
       screen -r sessionowner/[[pid.]tty[.host]]

DESCRIPTION
       Screen  is  a  full-screen  window manager that multiplexes a physical
       terminal between several  processes  (typically  interactive  shells).
       Each  virtual  terminal provides the functions of a DEC VT100 terminal
       and, in addition, several control functions from the  ISO  6429  (ECMA
       48,  ANSI  X3.64)  and ISO 2022 standards (e.g. insert/delete line and
       support for multiple character sets).  There is a  scrollback  history
       buffer  for  each virtual terminal and a copy-and-paste mechanism that
       allows moving text regions between windows.
</code></pre>
<p>使用 screen 很方便，有以下几个常用选项：</p>
<ul>
<li><p>  用screen -dmS session name来建立一个处于断开模式下的会话（并指定其会话名）。</p>
</li>
<li><p>  用screen -list 来列出所有会话。</p>
</li>
<li><p>  用screen -r session name来重新连接指定会话。</p>
</li>
<li><p>用快捷键CTRL-a d 来暂时断开当前会话。</p>
<h5 id="screen-示例"><a href="#screen-示例" class="headerlink" title="screen 示例"></a>screen 示例</h5><p>  [root@pvcent107 ~]# screen -dmS Urumchi [root@pvcent107 ~]# screen -list There is a screen on: 12842.Urumchi (Detached) 1 Socket in /tmp/screens/S-root. [root@pvcent107 ~]# screen -r Urumchi</p>
</li>
</ul>
<p>当我们用“-r”连接到 screen 会话后，我们就可以在这个伪终端里面为所欲为，再也不用担心 HUP 信号会对我们的进程造成影响，也不用给每个命令前都加上“nohup”或者“setsid”了。这是为什么呢？让我来看一下下面两个例子吧。</p>
<h5 id="1-未使用-screen-时新进程的进程树"><a href="#1-未使用-screen-时新进程的进程树" class="headerlink" title="1. 未使用 screen 时新进程的进程树"></a>1. 未使用 screen 时新进程的进程树</h5><pre><code>[root@pvcent107 ~]# ping www.google.com &amp;
[1] 9499
[root@pvcent107 ~]# pstree -H 9499
init─┬─Xvnc
     ├─acpid
     ├─atd
     ├─2*[sendmail] 
     ├─sshd─┬─sshd───bash───pstree
     │       └─sshd───bash───ping
</code></pre>
<p>我们可以看出，未使用 screen 时我们所处的 bash 是 sshd 的子进程，当 ssh 断开连接时，HUP 信号自然会影响到它下面的所有子进程（包括我们新建立的 ping 进程）。</p>
<h5 id="2-使用了-screen-后新进程的进程树"><a href="#2-使用了-screen-后新进程的进程树" class="headerlink" title="2. 使用了 screen 后新进程的进程树"></a>2. 使用了 screen 后新进程的进程树</h5><pre><code>[root@pvcent107 ~]# screen -r Urumchi
[root@pvcent107 ~]# ping www.ibm.com &amp;
[1] 9488
[root@pvcent107 ~]# pstree -H 9488
init─┬─Xvnc
     ├─acpid
     ├─atd
     ├─screen───bash───ping
     ├─2*[sendmail]
</code></pre>
<p>而使用了 screen 后就不同了，此时 bash 是 screen 的子进程，而 screen 是 init（PID为1）的子进程。那么当 ssh 断开连接时，HUP 信号自然不会影响到 screen 下面的子进程了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在几种方法已经介绍完毕，我们可以根据不同的场景来选择不同的方案。nohup/setsid 无疑是临时需要时最方便的方法，disown 能帮助我们来事后补救当前已经在运行了的作业，而 screen 则是在大批量操作时不二的选择了。 // &lt;![CDATA[ var _self=”undefined”!=typeof window?window:”undefined”!=typeof WorkerGlobalScope&amp;&amp;self instanceof WorkerGlobalScope?self:{},Prism=function(){var e=/\blang(?:uage)?-(\w+)\b/i,t=0,n=_self.Prism={util:{encode:function(e){return e instanceof a?new a(e.type,n.util.encode(e.content),e.alias):”Array”===n.util.type(e)?e.map(n.util.encode):e.replace(/&amp;/g,”&amp;”).replace(/&lt;/g,”&lt;”).replace(/\u00a0/g,” “)},type:function(e){return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1]},objId:function(e){return e.__id||Object.defineProperty(e,”__id”,{value:++t}),e.__id},clone:function(e){var t=n.util.type(e);switch(t){case”Object”:var a={};for(var r in e)e.hasOwnProperty(r)&amp;&amp;(a[r]=n.util.clone(e[r]));return a;case”Array”:return e.map&amp;&amp;e.map(function(e){return n.util.clone(e)})}return e}},languages:{extend:function(e,t){var a=n.util.clone(n.languages[e]);for(var r in t)a[r]=t[r];return a},insertBefore:function(e,t,a,r){r=r||n.languages;var l=r[e];if(2==arguments.length){a=arguments[1];for(var i in a)a.hasOwnProperty(i)&amp;&amp;(l[i]=a[i]);return l}var o={};for(var s in l)if(l.hasOwnProperty(s)){if(s==t)for(var i in a)a.hasOwnProperty(i)&amp;&amp;(o[i]=a[i]);o[s]=l[s]}return n.languages.DFS(n.languages,function(t,n){n===r[e]&amp;&amp;t!=e&amp;&amp;(this[t]=o)}),r[e]=o},DFS:function(e,t,a,r){r=r||{};for(var l in e)e.hasOwnProperty(l)&amp;&amp;(t.call(e,l,e[l],a||l),”Object”!==n.util.type(e[l])||r[n.util.objId(e[l])]?”Array”!==n.util.type(e[l])||r[n.util.objId(e[l])]||(r[n.util.objId(e[l])]=!0,n.languages.DFS(e[l],t,l,r)):(r[n.util.objId(e[l])]=!0,n.languages.DFS(e[l],t,null,r)))}},plugins:{},highlightAll:function(e,t){var a={callback:t,selector:’code[class*=”language-“], [class*=”language-“] code, code[class*=”lang-“], [class*=”lang-“] code’};n.hooks.run(“before-highlightall”,a);for(var r,l=a.elements||document.querySelectorAll(a.selector),i=0;r=l[i++];)n.highlightElement(r,e===!0,a.callback)},highlightElement:function(t,a,r){for(var l,i,o=t;o&amp;&amp;!e.test(o.className);)o=o.parentNode;o&amp;&amp;(l=(o.className.match(e)||[,””])[1],i=n.languages[l]),t.className=t.className.replace(e,””).replace(/\s+/g,” “)+” language-“+l,o=t.parentNode,/pre/i.test(o.nodeName)&amp;&amp;(o.className=o.className.replace(e,””).replace(/\s+/g,” “)+” language-“+l);var s=t.textContent,u={element:t,language:l,grammar:i,code:s};if(!s||!i)return n.hooks.run(“complete”,u),void 0;if(n.hooks.run(“before-highlight”,u),a&amp;&amp;_self.Worker){var c=new Worker(n.filename);c.onmessage=function(e){u.highlightedCode=e.data,n.hooks.run(“before-insert”,u),u.element.innerHTML=u.highlightedCode,r&amp;&amp;r.call(u.element),n.hooks.run(“after-highlight”,u),n.hooks.run(“complete”,u)},c.postMessage(JSON.stringify({language:u.language,code:u.code,immediateClose:!0}))}else u.highlightedCode=n.highlight(u.code,u.grammar,u.language),n.hooks.run(“before-insert”,u),u.element.innerHTML=u.highlightedCode,r&amp;&amp;r.call(t),n.hooks.run(“after-highlight”,u),n.hooks.run(“complete”,u)},highlight:function(e,t,r){var l=n.tokenize(e,t);return a.stringify(n.util.encode(l),r)},tokenize:function(e,t){var a=n.Token,r=[e],l=t.rest;if(l){for(var i in l)t[i]=l[i];delete t.rest}e:for(var i in t)if(t.hasOwnProperty(i)&amp;&amp;t[i]){var o=t[i];o=”Array”===n.util.type(o)?o:[o];for(var s=0;s&lt;o.length;++s){var u=o[s],c=u.inside,g=!!u.lookbehind,h=!!u.greedy,f=0,d=u.alias;u=u.pattern||u;for(var p=0;p&lt;r.length;p++){var m=r[p];if(r.length&gt;e.length)break e;if(!(m instanceof a)){u.lastIndex=0;var y=u.exec(m),v=1;if(!y&amp;&amp;h&amp;&amp;p!=r.length-1){var b=r[p+1].matchedStr||r[p+1],k=m+b;if(p&lt;r.length-2&amp;&amp;(k+=r[p+2].matchedStr||r[p+2]),u.lastIndex=0,y=u.exec(k),!y)continue;var w=y.index+(g?y[1].length:0);if(w&gt;=m.length)continue;var <em>=y.index+y[0].length,P=m.length+b.length;if(v=3,P&gt;=</em>){if(r[p+1].greedy)continue;v=2,k=k.slice(0,P)}m=k}if(y){g&amp;&amp;(f=y[1].length);var w=y.index+f,y=y[0].slice(f),<em>=w+y.length,S=m.slice(0,w),O=m.slice(</em>),j=[p,v];S&amp;&amp;j.push(S);var A=new a(i,c?n.tokenize(y,c):y,d,y,h);j.push(A),O&amp;&amp;j.push(O),Array.prototype.splice.apply(r,j)}}}}}return r},hooks:{all:{},add:function(e,t){var a=n.hooks.all;a[e]=a[e]||[],a[e].push(t)},run:function(e,t){var a=n.hooks.all[e];if(a&amp;&amp;a.length)for(var r,l=0;r=a[l++];)r(t)}}},a=n.Token=function(e,t,n,a,r){this.type=e,this.content=t,this.alias=n,this.matchedStr=a||null,this.greedy=!!r};if(a.stringify=function(e,t,r){if(“string”==typeof e)return e;if(“Array”===n.util.type(e))return e.map(function(n){return a.stringify(n,t,e)}).join(“”);var l={type:e.type,content:a.stringify(e.content,t,r),tag:”span”,classes:[“token”,e.type],attributes:{},language:t,parent:r};if(“comment”==l.type&amp;&amp;(l.attributes.spellcheck=”true”),e.alias){var i=”Array”===n.util.type(e.alias)?e.alias:[e.alias];Array.prototype.push.apply(l.classes,i)}n.hooks.run(“wrap”,l);var o=””;for(var s in l.attributes)o+=(o?” “:””)+s+’=”‘+(l.attributes[s]||””)+’”‘;return”&lt;”+l.tag+’ class=”‘+l.classes.join(“ “)+’” ‘+o+”&gt;”+l.content+”&lt;/“+l.tag+”&gt;”},!_self.document)return _self.addEventListener?(_self.addEventListener(“message”,function(e){var t=JSON.parse(e.data),a=t.language,r=t.code,l=t.immediateClose;_self.postMessage(n.highlight(r,n.languages[a],a)),l&amp;&amp;_self.close()},!1),_self.Prism):_self.Prism;var r=document.currentScript||[].slice.call(document.getElementsByTagName(“script”)).pop();return r&amp;&amp;(n.filename=r.src,document.addEventListener&amp;&amp;!r.hasAttribute(“data-manual”)&amp;&amp;document.addEventListener(“DOMContentLoaded”,n.highlightAll)),_self.Prism}();”undefined”!=typeof module&amp;&amp;module.exports&amp;&amp;(module.exports=Prism),”undefined”!=typeof global&amp;&amp;(global.Prism=Prism); // ]]&gt; // &lt;![CDATA[ !function(){“undefined”!=typeof self&amp;&amp;self.Prism&amp;&amp;self.document&amp;&amp;Prism.hooks.add(“complete”,function(e){if(e.code){var t=e.element.parentNode,s=/\s*\bline-numbers\b\s*/;if(t&amp;&amp;/pre/i.test(t.nodeName)&amp;&amp;(s.test(t.className)||s.test(e.element.className))&amp;&amp;!e.element.querySelector(“.line-numbers-rows”)){s.test(e.element.className)&amp;&amp;(e.element.className=e.element.className.replace(s,””)),s.test(t.className)||(t.className+=” line-numbers”);var n,a=e.code.match(/\n(?!$)/g),l=a?a.length+1:1,m=new Array(l+1);m=m.join(“<span></span>“),n=document.createElement(“span”),n.className=”line-numbers-rows”,n.innerHTML=m,t.hasAttribute(“data-start”)&amp;&amp;(t.style.counterReset=”linenumber “+(parseInt(t.getAttribute(“data-start”),10)-1)),e.element.appendChild(n)}}})}(); // ]]&gt; // &lt;![CDATA[ !function(){if(“undefined”!=typeof self&amp;&amp;self.Prism&amp;&amp;self.document){var e={html:”HTML”,xml:”XML”,svg:”SVG”,mathml:”MathML”,css:”CSS”,clike:”C-like”,javascript:”JavaScript”,abap:”ABAP”,actionscript:”ActionScript”,apacheconf:”Apache Configuration”,apl:”APL”,applescript:”AppleScript”,asciidoc:”AsciiDoc”,aspnet:”ASP.NET (C#)”,autoit:”AutoIt”,autohotkey:”AutoHotkey”,basic:”BASIC”,csharp:”C#”,cpp:”C++”,coffeescript:”CoffeeScript”,”css-extras”:”CSS Extras”,fsharp:”F#”,glsl:”GLSL”,http:”HTTP”,inform7:”Inform 7”,json:”JSON”,latex:”LaTeX”,lolcode:”LOLCODE”,matlab:”MATLAB”,mel:”MEL”,nasm:”NASM”,nginx:”nginx”,nsis:”NSIS”,objectivec:”Objective-C”,ocaml:”OCaml”,parigp:”PARI/GP”,php:”PHP”,”php-extras”:”PHP Extras”,powershell:”PowerShell”,jsx:”React JSX”,rest:”reST (reStructuredText)”,sas:”SAS”,sass:”Sass (Sass)”,scss:”Sass (Scss)”,sql:”SQL”,typescript:”TypeScript”,vhdl:”VHDL”,vim:”vim”,wiki:”Wiki markup”,yaml:”YAML”};Prism.hooks.add(“before-highlight”,function(s){var a=s.element.parentNode;if(a&amp;&amp;/pre/i.test(a.nodeName)){var t,i,r=a.getAttribute(“data-language”)||e[s.language]||s.language.substring(0,1).toUpperCase()+s.language.substring(1),l=a.previousSibling;l&amp;&amp;/\s*\bprism-show-language\b\s*/.test(l.className)&amp;&amp;l.firstChild&amp;&amp;/\s*\bprism-show-language-label\b\s*/.test(l.firstChild.className)?i=l.firstChild:(t=document.createElement(“div”),i=document.createElement(“div”),i.className=”prism-show-language-label”,t.className=”prism-show-language”,t.appendChild(i),a.parentNode.insertBefore(t,a)),i.innerHTML=r}})}}(); // ]]&gt; // &lt;![CDATA[ if (typeof MathJaxListener !== ‘undefined’) { MathJax.Hub.Register.StartupHook(‘End’, function () { MathJaxListener.invokeCallbackForKey_(‘End’); }); } // ]]&gt;</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>nextjs静态页面github pages资源文件404</title>
    <url>/2021/02/12/nextjs%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2github-pages%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6404/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>通过把nextjs的静态文件放到github pages上，省一波流量钱，但是发现资源文件总是会404，本来以为是github pages构建完成更新cdn需要缓存，但是过了很久都没有成功，以下是静态文件目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- _next</span><br><span class="line">   -- chunks</span><br><span class="line">      -- *.js</span><br><span class="line">   -- css</span><br><span class="line">      -- *.css</span><br></pre></td></tr></table></figure>

<p>后来做了猜想是目录深度原因，但是测试下来还是没有用。 后面经过验证是 下划线开头的文件或者文件夹的原因， 折腾了好半天。 实际的原因只是因为 github pages使用jeklly引擎的默认规则。</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><ul>
<li>避免使用下划线开头的文件(需要重新)</li>
<li>通过在根目录创建.nojekyll 空文件, 关闭jeklly引擎</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- .nojekyll</span><br><span class="line">-- _next</span><br><span class="line">   -- chunks</span><br><span class="line">      -- *.js</span><br><span class="line">   -- css</span><br><span class="line">      -- *.css</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>FE</category>
      </categories>
      <tags>
        <tag>FE</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1061</title>
    <url>/2013/04/28/poj1061/</url>
    <content><![CDATA[<p>题意就不赘诉了，青蛙约会。是一个关于欧几里得扩展的定理的题目</p>
<p>int gcd(int a,int b)//欧几里得求最大公约数<br>{<br>    if (b==0) return a;<br>    return gcd(b,a%b);<br>}</p>
<p>int exgcd(int a,int b,int &amp;x,int &amp;y)//欧几里得扩展求ax+by=gcd(a,b)的一组解<br>{<br>   if (b==0) {x=1;y=0;return a;}<br>   int r=exgcd(b,a%b,x,y);<br>   int t=x;<br>   x=y;<br>   y=t-a/b*y;<br>   return r;<br>}</p>
<p>针对本题，需要注意的是，    1.数据比较大，需要用long long 2.因为是时间，所以x不能是负数，如果出现负数怎么办呢？ a*x1+b*y1=d(d=gcd(a,b)),那个转换成 a*(x1+b*n）+b*（y1-a*n)=d 最终x=(x1%b+b)%b;或者(x1+(abs([x1/b])+1)*b)%b; AC代码：</p>
<p>#include #include #include #include #include using namespace std;</p>
<p>int gcd(int a,int b)<br>{<br>    if (b==0) return a;<br>    return gcd(b,a%b);<br>}<br>long long exgcd(long long a,long long b,long long &amp;x,long long &amp;y)<br>{<br>    if (b==0){ x=1;y=0;return a;}<br>    long long r=exgcd(b,a%b,x,y);<br>    long long t=x;<br>    x=y;<br>    y=t-(a/b)*y;<br>    return r;<br>}<br>int main()<br>{<br>    long long x,y,m,n,L;<br>    cin&gt;&gt;x&gt;&gt;y&gt;&gt;m&gt;&gt;n&gt;&gt;L;<br>    long long s=gcd(n-m,L);<br>    if ((x-y)%s!=0){<br>    cout&lt;&lt;”Impossible”&lt;</p>
]]></content>
      <categories>
        <category>ACMICPC</category>
      </categories>
  </entry>
  <entry>
    <title>POJ 1015</title>
    <url>/2013/04/25/poj1015/</url>
    <content><![CDATA[<p>原题的题意是给n个人，每个人对于控辩两方都有一个值，现在选择m个人，使得控辩两方的值的差的和最小，如果有相同的最小值，那么就选择最大的一个。 本题的关键是模型的构建，对于每个人都有两种选择，一个是选择，一个是不选择，对于相同的差值，维护一个最大的和值，换言之，就是假设差值一定，从n个人选择m个人使得和最大.可以转换为背包问题。状态转移的方程为f[i][j][k+p[i]]=max{f[i-1][j][k+p[i]],f[i-1][j-1][k]+v[i]},表示前i个人中选择j个人差的和为k的最大的和的和（p[i]是第i个人的控辩双方的值差，v[i]是第i个人的控辩双方的值和）.本题的另外一个难点在于路径的记录，我们知道，动态规划的一个本质就是状态转移，也就是在当前状态记录是由哪个值推倒过来的，就可以逆序退出上个状态的值。同时通过对路径的遍历，从而可以判断当前的第i个人是否被选择过，从而达到了降维的作用。</p>
<span id="more"></span>

<p>#include #include #include #include #include using namespace std;<br>int a[201],b[201];<br>int f[30][801],path[30][801];<br>int p[205],v[205];<br>bool select(int i,int j,int k)<br>{<br>    while (true)<br>    {<br>        if (path[i][k]&lt;0 || i&lt;0) break;<br>         if (j==path[i][k]) return true;<br>        k=k-p[path[i][k]];<br>        i–;<br>    }<br>    return false;<br>}<br>int main()<br>{<br>    int n,m;<br>    int No=0;<br>    while (scanf(“%d%d”,&amp;n,&amp;m)!=EOF &amp;&amp; n+m!=0){<br>        cout&lt;&lt;”Jury #”&lt;&lt;++No&lt;=0){<br>                for (int j=0;j=0 &amp;&amp; f[m][m*20+i]&gt;=f[m][m*20-i])<br>                {<br>                    k=m<em>20+i;<br>                    break;<br>                }<br>                if (f[m][m</em>20-i]&gt;=0){<br>                    k=m<em>20-i;<br>                    break;<br>                }<br>            }<br>        int suma=0,sumb=0;<br>        int id[300];<br>        int sum=0;<br>        while (true)<br>        {<br>            int i=path[m–][k];<br>            if (i==-1 || m&lt;0) break;<br>            id[sum++]=i;<br>            suma+=a[i];<br>            sumb+=b[i];<br>            k=k-p[i];<br>        }<br>        cout&lt;&lt;”Best jury has value “&lt; #include #include #include #include using namespace std;<br>int a[201],b[201];<br>int f[30][801],path[30][801];<br>int p[205],v[205];<br>bool select(int i,int j,int k)<br>{<br>    while (true)<br>    {<br>        if (path[i][k]&lt;0 || i&lt;0) break;<br>         if (j==path[i][k]) return true;<br>        k=k-p[path[i][k]];<br>        i–;<br>    }<br>    return false;<br>}<br>int main()<br>{<br>    int n,m;<br>    int No=0;<br>    while (scanf(“%d%d”,&amp;n,&amp;m)!=EOF &amp;&amp; n+m!=0){<br>        cout&lt;&lt;”Jury #”&lt;&lt;++No&lt;=0){<br>                for (int j=0;j=0 &amp;&amp; f[m][m*20+i]&gt;=f[m][m*20-i])<br>                {<br>                    k=m</em>20+i;<br>                    break;<br>                }<br>                if (f[m][m<em>20-i]&gt;=0){<br>                    k=m</em>20-i;<br>                    break;<br>                }<br>            }<br>        int suma=0,sumb=0;<br>        int id[300];<br>        int sum=0;<br>        while (true)<br>        {<br>            int i=path[m–][k];<br>            if (i==-1 || m&lt;0) break;<br>            id[sum++]=i;<br>            suma+=a[i];<br>            sumb+=b[i];<br>            k=k-p[i];<br>        }<br>        cout&lt;&lt;”Best jury has value “&lt;</p>
]]></content>
      <categories>
        <category>ACMICPC</category>
      </categories>
  </entry>
  <entry>
    <title>POJ 1422</title>
    <url>/2013/04/28/poj1422/</url>
    <content><![CDATA[<p>题意不追溯，关于匈牙利算法看：<a href="http://my.oschina.net/xuwei8091/blog/126320">http://my.oschina.net/xuwei8091/blog/126320</a>。 最小路径覆盖等于N-最大匹配</p>
<p>#include #include #include using namespace std;<br>int T;<br>int n,m;<br>int map[200][200];<br>int vis[200];<br>int result[200];<br>bool find(int s)<br>{<br>        for (int i=1;i&lt;=n;i++)<br>        {<br>            if (map[s][i] &amp;&amp; !vis[i])<br>            {<br>                vis[i]=1;<br>                if (result[i]==0 || find(result[i]))<br>                {<br>                    result[i]=s;<br>                    return true;<br>                }<br>            }<br>        }<br>        return false;<br>}<br>int main()<br>{<br>    scanf(“%d”,&amp;T);<br>    while (T–){<br>        memset(map,0,sizeof(map));<br>        memset(result,0,sizeof(result));<br>        scanf(“%d%d”,&amp;n,&amp;m);<br>        for (int i=0;i</p>
]]></content>
      <categories>
        <category>ACMICPC</category>
      </categories>
  </entry>
  <entry>
    <title>x&amp;(-x)取x的最后一个1的证明</title>
    <url>/2015/04/22/proof/</url>
    <content><![CDATA[<p><a href="http://xtestw.site/?p=29">http://xtestw.site/?p=29</a></p>
<p>##x&amp;(-x)取x的最后一个1的证明##<br>明天要给新队员讲树状数组，避不开的一个证明，之前教主讲过，当时没听明白给忘了- -，只有自己想了一种证明方法。</p>
<p>#####证明#####<br>大家都知道，计算机是用补码来存储一个数的，在这种编码情况下，整数是自然状态编码，假设我们是一个5位的机器（只是假设），那么1，编码就为00001, 而-1的编码则是11111(并不是10001)，在这种情况下，我们会有下面的结论：</p>
<pre><code>             -x=11111 – x +1 (x 假设为正数二进制)  -----------------结论一
              x=00000 + x (x 假设为正数二进制) ----------------------结论二
</code></pre>
<p>我们还会有以下2个结论：</p>
<pre><code>结论三：11111 - x 不会出现借位的情况(二进制下 ，对应位只会是两种情况 1-0 和 1-1)
结论四：00000 + x 不会出现进位的情况（二进制下，对应位只会是 0+1,0+0）
</code></pre>
<p>假设 x的二进制编码为 x1 x2 x3 x4 x5</p>
<p>那么我们就会发现 对于任何一位(以x1为例) 0+x1 和 1-x1 两个 必然是一个为1 一个为0，因为：</p>
<table>
<tr><td>X1的值</td>    <td>0+x1</td>    <td>1-x1</td></tr>
<tr><td>0</td>    <td>0</td>    <td>1</td></tr>
<tr><td>1</td>    <td>1</td>    <td>0</td></tr>
</table>

<span id="more"></span>

<p>有了上面的结论，<strong>我们把焦点放到x的最后几位</strong>，我们要分离的是最后一个1，那么假设是第i位xi是最后一个1，那么i位以后的每一位都是0，在这个基础上，根据上面这个表格，我们会发现，11111-x 这个值在第i位以后全部都是1，而第i位为0，整理一下，每一位如下：</p>
<ol>
<li>X的每一位为  x1 ,x2,…… xi-1, 1 ,0,0,0…. 后面每一位都是0<ol start="2">
<li>11111-x 结果的每一位为 1-X1,1-X2,….1-Xi-1 ,0,1,1,1….. 后面每一位都是1</li>
</ol>
</li>
</ol>
<p>下面这一点是关键 ，就是 –x = 11111-x +1, 也就是说-x的每一位是这样的：</p>
<pre><code>                    1-X1,1-X2,….1-Xi-1 ,1,0,0,0…..
</code></pre>
<p>也就是说，最后一位+1 ，然后会变成0 一直往前进位到第i位，将第i位变成1后停止进位， 我们现在比较一下 x 和 –x的每一位的值， 会发现 ，<strong>除了第i位为一样的1，其余每一位都是不一样的</strong>即，都是一组0,1. 那么 </p>
<pre><code>                    X&amp;(-X)= 0,0,0….1, 0,0,0,….
</code></pre>
<p><strong>除了第i位是1，其他每一位的值都是0</strong>， 而根据我们最开始所说的，<strong>X的第i位的1就是X当前二进制编码的最后一个1</strong>，所以通过 x &amp;(-x) 我们能够得到x的最后一个</p>
]]></content>
      <categories>
        <category>ACMICPC</category>
      </categories>
  </entry>
  <entry>
    <title>RSA整理</title>
    <url>/2016/05/24/rsa-e6-95-b4-e7-90-86/</url>
    <content><![CDATA[<p>最近的论文用到了RSA相关的东西，做一个整理。</p>
<ul>
<li><a href="#toc_0">RSA</a><ul>
<li>  <a href="#toc_1">流程图</a></li>
<li>  <a href="#toc_2">选取2个质数p、q</a></li>
<li>  <a href="#toc_3">计算n = p * q</a></li>
<li>  <a href="#toc_4">计算欧拉函数 φ(n)</a></li>
<li>  <a href="#toc_5">选择加密密钥 e</a></li>
<li>  <a href="#toc_6">计算解密密钥 d</a></li>
<li>  <a href="#toc_7">加密解密</a></li>
</ul>
</li>
</ul>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><ul>
<li>  密钥生成过程： <img src="http://imgdata.hoop8.com/1605/3863736210165.png" alt="RSA"></li>
<li>  加密解密过程： <img src="http://imgdata.hoop8.com/1605/1503736210165.png" alt="RSA"></li>
</ul>
<h2 id="选取2个质数p、q"><a href="#选取2个质数p、q" class="headerlink" title="选取2个质数p、q"></a>选取2个质数p、q</h2><p>\(RSA\)算法的主要就是基于一个十分简单的数论事实：将两个大素数相乘十分容易，但是想要对其乘积进行因式分解却极其困难。 同时为了增强强度，\(p-1\)和\(q-1\)的最大公因子要小 质数的选取方法：</p>
<ul>
<li>  随机搜索法随机产生一个奇数 \(p_1\) 进行素数测试,若是素数,则结束;否则,重新随机产生一个奇数 \(p_2\) 进行素性测试,直至找到一个素数 \(p_t\)。</li>
<li>  随机递增搜索法随机产生一个奇数,对以该数为起点的奇数依次进行测试,直至找到一个素数。这种方法相对于随机搜索法，在速度上有一定的提高，但是并没有本质上的区别</li>
</ul>
<span id="more"></span>

<p>设:</p>
<p>\(p=61,q=53\)</p>
<h2 id="计算n-p-q"><a href="#计算n-p-q" class="headerlink" title="计算n = p * q"></a>计算n = p * q</h2><p>\(n\)是公钥对，密钥对都需要的一个值，为提高保密强度，RSA密钥至少为500位长，一般推荐使用1024位，也有2048位的。</p>
<p>\( n = p*q=61*53 = 3233 \)</p>
<p>这个部分是可以直接求解的。</p>
<h2 id="计算欧拉函数-ϕ-n"><a href="#计算欧拉函数-ϕ-n" class="headerlink" title="计算欧拉函数 ϕ(n)"></a>计算欧拉函数 ϕ(n)</h2><p>\( \phi(n) = (p-1)(q-1) = 60*52 = 3120 \)</p>
<h2 id="选择加密密钥-e"><a href="#选择加密密钥-e" class="headerlink" title="选择加密密钥 e"></a>选择加密密钥 e</h2><p>加密密钥 \(e\) 需要满足以下条件：</p>
<p>\(1 &lt; e &lt; \phi(n), gcd(e, \phi(n)) = 1\)</p>
<p>这个条件是为了确保\(e\)在模\(\phi(n)\)的情况下有逆元。出于安全性考虑 \(e=2\) 永远不该被使用 一般生成这种\(e\)的方法有2种：</p>
<ul>
<li>  随机生成法</li>
<li>  穷举法</li>
</ul>
<p>我们令</p>
<p>\(e = 17 \)</p>
<p>即我们得到公钥对：</p>
<p>\(PU\ = \ \{\ e,n\ \} = \{\ 17,3233\ \} \)</p>
<h2 id="计算解密密钥-d"><a href="#计算解密密钥-d" class="headerlink" title="计算解密密钥 d"></a>计算解密密钥 d</h2><p>解密密钥 \(d\) 需要满足：</p>
<p>\(d \equiv\) \(e\)-1 \( \ \ (\ mod\ \phi(n) \ )\)</p>
<p>其实求的就是\(e\)的逆元，求逆元的方法有3种：</p>
<ul>
<li><p>  循环求解法枚举所有的数，来求解\(e\)的逆元</p>
</li>
<li><p>扩展欧几里</p>
<blockquote>
<p>扩展欧几里得算法可以在求得a、b的最大公约数的同时，能找到整数\(x、y\)（其中一个很可能是负数），使它们满足贝祖等式\(ax + by = gcd(a, b)\)。</p>
</blockquote>
</li>
</ul>
<p>当\(gcd(a, b)=1\),那么\((ax + by = 1)\),此时可以看出\(m\)是\(a\)模\(b\)的乘法逆元，\(n\)是\(b\)模\(a\)的乘法逆元。</p>
<blockquote>
<p>扩展欧几里德计算过程：</p>
<p>\(a = q_1b + r_1 \ \ \ r_1 = ax_1+by_1\)</p>
<p> </p>
<p>\(b = q_2r_1 + r_2 \ \ \ r_2 = ax_2+by_2\)</p>
<p> </p>
<p>\(r_1 = q_3b + r_3 \ \ \ r_3 = ax_3+by_3\)</p>
<p> </p>
<p>…</p>
<p> </p>
<p>\(r_{n-2}= q_nr_{n-1} + r_n \ \ \ r_n = ax_n+by_n\)</p>
<p> </p>
<p>\(r_{n-1}= q_{n+1}r_{n} + 0 \)</p>
<p>通过移项，得到：</p>
<p>\(r_i = r_{i-2}-r_{i-1}q_i\)</p>
<p>同样，从i-1和i-2行，也可以得到:</p>
<p>\(r_{i-2} = ax_{i-2}+by_{i-2}\ \ \ \ \ r_{i-1}=ax_{i-1}+by_{i-1}\)</p>
<p>代入：</p>
<p>\(r_i =a(x_{i-2} - q_ix_{i-1})+b(y_{i-2}-q_iy_{i-1})\)</p>
<p>因为我们已经假设\(r_i=ax_i+by_i\),因此</p>
<p>\(x_i =x_{i-2} - q_ix_{i-1}\ \ \ \ \ y_i=y_{i-2} - q_iy_{i-1}\)</p>
<p>#include <iostream><br>#include <cstdio><br>#define LL __int64<br>using namespace std;<br>LL extend_gcd(LL a, LL b, LL &amp;x, LL &amp;y)//ax+by=1返回a,b的gcd<br>{<br>    LL ans, t;<br>    if(b == 0)<br>    {<br>        x = 1;<br>        y = 0;<br>        return a;<br>    }<br>    ans = extend_gcd(b, a%b, x, y);<br>    t = x;<br>    x = y;<br>    y = t - ( a / b ) * y;<br>    return ans;<br>}<br>int main()<br>{<br>    LL a, b, c, x, y;<br>    while(~scanf(“%I64d%I64d%I64d”, &amp;a, &amp;b, &amp;c))//ax+by = c<br>    {<br>        LL gcd = extend_gcd(a,b,x,y);<br>        while(x &lt; 0)//x 为正<br>            x += b,y -= a;<br>        printf(“ax+by = 1的最小正整数解:%I64d %I64d\n”, x, y);//ax+by = 1<br>        //x即为a%b的逆元，y为b%a的逆元<br>        printf(“a mod b的逆元:%I64d\n”, x);<br>        if(c % gcd)<br>        {<br>            printf(“无解！\n”);<br>            continue;<br>        }//ax+by = c<br>        printf(“x=%I64d,y=%I64d\n”, x*c/gcd, y*c/gcd);<br>    }<br>    return 0;<br>}</p>
</blockquote>
<ul>
<li><p>费马小定理成立的前提是\(\phi(n)\)为质数，否则无法使用。 假如\(a\)是整数，\(p\)是质数，且\(a,p\)互质(即两者只有一个公约数1)，那么\(a\)的\((p-1)\)次方除以\(p\)的余数恒等于1。那么逆元为</p>
<p>  \(a\)\(m-2\)\(\ mod\ m \)</p>
</li>
</ul>
<p>利用扩展欧几里得算法可以求得：</p>
<p>\(d=2753\)</p>
<p>即我们得到密钥对：</p>
<p>\(PR\ =\ \{\ d,n\ \} = \{\ 2753,3233\ \}\)</p>
<h2 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h2><ul>
<li><p>加密</p>
<p>  \(C = M^e\ (\ mod\ n\ )\)</p>
</li>
</ul>
<p>假设对65加密,即\(M=65\)则：</p>
<p>\(C=65\)17 \(mod \ 3233 = 2790\)</p>
<ul>
<li><p>解密</p>
<p>  \(M = C^d\ (\ mod\ n\ )\)</p>
</li>
</ul>
<p>针对密文\(C=2790\)的情况，我们进行解密：</p>
<p>\(M = 2790\)2753 \(\ mod\ 3233 = 65.\)</p>
<blockquote>
<p>求高次幂的快速幂算法: 比如求解：</p>
<p>\(a^b\ mod\ n\)</p>
<p>把b转换成二进制数,该二进制数第\(i\)位的权为 2\(i\)-1 例如, \(b=11\)的二进制是1011</p>
<p>11 = 23 ×1 + 22 ×0 + 21 ×1 + 20 ×1</p>
<p>因此，我们将\(a\)11 转化为算</p>
<p>\( a\)11 =\(a\)20 *\(a\)21 * \(a\)23</p>
<p>int modexp(int a,int b,int n)<br>{<br>    int ret=1;<br>    while(b)<br>    {<br>       if(b&amp;1) ret=ret<em>a%n;<br>       a=a</em>a%n;<br>       b&gt;&gt;=1;<br>    }<br>    return ret;<br>}</p>
</blockquote>
<p>// &lt;![CDATA[ if (typeof MathJaxListener !== ‘undefined’) { MathJax.Hub.Register.StartupHook(‘End’, function () { MathJaxListener.invokeCallbackForKey_(‘End’); }); } // ]]&gt;</p>
]]></content>
      <categories>
        <category>Theory</category>
      </categories>
      <tags>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title>sdk篡改</title>
    <url>/2017/07/23/sdk-e7-af-a1-e6-94-b9/</url>
    <content><![CDATA[<p>前段时间，因为一年前篡改了一个sdk的包，导致了一系列不可预知的损失，这也充分说明了技术的正确性，需要决策的正确性来支撑的。作为技术人员，不仅仅要考虑技术的可行性，也要考虑实施后的风险和结果的预期假设。 从工程角度，简单记录一下篡改sdk包的技术。</p>
<ol>
<li>解压jar或者apk的包 </li>
<li>JD-GUI 反编译查看class的相关代码，找到修改点</li>
<li>自己编写相应的方法或者类，使用 <code>javaassist</code> 注入到class文件 </li>
<li>重新打包</li>
</ol>
<p> <code>javassist</code> 使用方法参考： <a href="https://jboss-javassist.github.io/javassist/tutorial/tutorial.html">https://jboss-javassist.github.io/javassist/tutorial/tutorial.html</a> 附上测试代码，修改一个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      javassist.tools.reflect.<span class="type">Loader</span> <span class="variable">cl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">javassist</span>.tools.reflect.Loader();</span><br><span class="line">      <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">      pool.insertClassPath(<span class="string">&quot;/tmp/aa/&quot;</span>);</span><br><span class="line">      <span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.get(<span class="string">&quot;com.facebook.ads.internal.d.g&quot;</span>);</span><br><span class="line">      <span class="type">CtMethod</span> <span class="variable">ctmethod</span> <span class="operator">=</span> cc.getDeclaredMethod(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">      cc.getDeclaredField(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">      <span class="comment">// getCode()即为需要替换的的代码</span></span><br><span class="line">      ctmethod.setBody(getCode());</span><br><span class="line">      cc.writeFile(<span class="string">&quot;/tmp/aa/&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CannotCompileException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NotFoundException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2013/04/27/set/</url>
    <content><![CDATA[<p>好吧，前两天做了一场CF，遇到一道并查集的题目，感觉并查集还需学习啊，记录一下 具体的算法如下</p>
<ol>
<li>有father数组，全部初始化为本身 </li>
<li>添加一个关系进来的时候，s–t，找到s的祖先a,t的祖先b，将a的father设为b </li>
<li>通过查找祖先，来确定是否在一个集合内</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;<span class="comment">//初始化，节点编号1-n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) father[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//查找祖先节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (father[x]!=x) x=father[x];</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> t)</span><span class="comment">//增加一个关系，改变集合</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> a=<span class="built_in">find</span>(s);</span><br><span class="line">  <span class="type">int</span> b=<span class="built_in">find</span>(t);</span><br><span class="line">  father[a]=b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> t)</span><span class="comment">//判断是不是一个集合</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(s)==<span class="built_in">find</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACMICPC</category>
      </categories>
  </entry>
  <entry>
    <title>windows核心编程-错误处理</title>
    <url>/2015/01/29/windows-e6-a0-b8-e5-bf-83-e7-bc-96-e7-a8-8b-e9-94-99-e8-af-af-e5-a4-84-e7-90-86/</url>
    <content><![CDATA[<p>1.常见的错误返回类型</p>
<p>VOID/BOOL/HANDLE/PVOID/LONG/DWORD VOID 不可能失败 BOOL 错误返回false 编码的时候最好测试是否不为FALSE HANDLE 错误 NULL/INVALID_HANDLE_VALUE PVOID  失败返回NULL,成功返回一个数据块的地址 LONG/DWORD 0或-1，不绝对 2.GetLastError函数   DWORD GetLastError(); 3.WinError.h 头文件定义了若干的Mircosoft定义的代码列表 4.</p>
]]></content>
      <categories>
        <category>ACMICPC</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>关于大数据的C(M,N)</title>
    <url>/2013/05/01/%E5%85%B3%E4%BA%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84C(M,N)/</url>
    <content><![CDATA[<p>cf181 div 2的C题<a href="http://codeforces.com/contest/300/problem/C">http://codeforces.com/contest/300/problem/C</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">cal</span><span class="params">(<span class="type">long</span> <span class="type">long</span> s)</span><span class="comment">//s^(MOD-2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="type">long</span> <span class="type">long</span> ans=<span class="number">1</span>;</span><br><span class="line">     <span class="type">long</span> <span class="type">long</span> n=MOD<span class="number">-2</span>;</span><br><span class="line">     <span class="keyword">while</span> (n!=<span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span> (n&amp;<span class="number">1</span>) ans=ans*s%MOD;</span><br><span class="line">         s=s*s;</span><br><span class="line">         n=n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">C</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span><span class="comment">//f[x]=x! 求的是C(m,n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> f[m]*<span class="built_in">cal</span>(f[n]*f[m-n]%MOD)%MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>//CF181D2C </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a,b,n;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[<span class="number">1000001</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">power</span><span class="params">(<span class="type">long</span> <span class="type">long</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n=MOD<span class="number">-2</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n&amp;<span class="number">1</span>) ans=(ans*s)%MOD;</span><br><span class="line">        s=(s*s)%MOD;</span><br><span class="line">        n=n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans%MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[n]*<span class="built_in">power</span>(f[n-i]*f[i]%MOD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (s!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t=s%<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (t!=a &amp;&amp; t!=b) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        s=s/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;n);</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n<span class="number">+1</span>;i++)&#123;</span><br><span class="line">      f[i]=(i*f[i<span class="number">-1</span>])%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(i*a+(n-i)*b))&#123;ans=(ans+<span class="built_in">C</span>(n,i))%MOD;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACMICPC</category>
      </categories>
      <tags>
        <tag>proof,acm</tag>
      </tags>
  </entry>
  <entry>
    <title>几种简单的传统加密算法概述</title>
    <url>/2013/11/10/%E5%87%A0%E7%A7%8D%E7%AE%80%E5%8D%95%E7%9A%84%E4%BC%A0%E7%BB%9F%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>本文只是概述几种简单的传统加密算法，没有DES,没有RSA，没有想象中的高端大气上档次的东东。。。但是都是很传统很经典的一些算法 首先，提到加密，比如加密一段文字，让其不可读，一般人首先会想到的是将其中的各个字符用其他一些特定的字符代替，比如，讲所有的A用C来表示，所有的C用E表示等等…其中早的代替算法就是由Julius Caesar发明的Caesar，它是用字母表中每个字母的之后的第三个字母来代替其本身的（C=E(3，p)=（p+3) mod 26)，但是，这种加密方式，很容易可以用穷举算法来破解，毕竟只有25种可能的情况.. 为了改进上诉算法，增加其破解的难度，我们不用简单的有序的替代方式，我们让替代无序化，用其中字母表的一个置换（置换：有限元素的集合S的置换就是S的所有元素的有序排列，且每个元素就出现一次，如S={a,b}其置换就只有两种:ab,ba），这样的话，就有26！种方式，大大的增加了破解的难度，但是这个世界聪明人太多，虽然26！很多，但是语言本身有一定的特性，每个字母在语言中出现的相对频率可以统计出来的，这样子，只要密文有了一定数量，就可以从统计学的角度，得到准确的字母匹配了。 上面的算法我们称之为单表代替，其实单表代替密码之所以较容易被攻破，因为它带有原始字母使用频率的一些统计学特征。有两种主要的方法可以减少代替密码里明文结构在密文中的残留度，一种是对明文中的多个字母一起加密，另一种是采用多表代替密码。 先说多字母代替吧，最著名的就是playfair密码，它把明文中的双字母音节作为一个单元并将其转换成密文的双字母音节，它是一个基于由密钥词构成的5<em>5的字母矩阵中的，一个例子，如密钥为monarchy，将其从左往右从上往下填入后，将剩余的字母依次填入剩下的空格，其中I/J填入同一个空格: <a href="http://static.oschina.net/uploads/img/201311/10123647_Q0Ls.png"><img src="http://static.oschina.net/uploads/img/201311/10123647_Q0Ls.png"></a> 对明文加密规则如下： 1 若p1 p2在同一行，对应密文c1 c2分别是紧靠p1 p2 右端的字母。其中第一列被看做是最后一列的右方。 2 若p1 p2在同一列，对应密文c1 c2分别是紧靠p1 p2 下方的字母。其中第一行被看做是最后一行的下方。 3 若p1 p2不在同一行，不在同一列，则c1 c2是由p1 p2确定的矩形的其他两角的字母，并且c1和p1， c2和p2同行。 4 若p1 p2相同，则插入一个事先约定的字母，比如Q 。 5 若明文字母数为奇数时，则在明文的末端添加某个事先约定的字母作为填充。 虽然相对简单加密，安全性有所提高，但是还是保留了明文语言的大部分结构特征，依旧可以破解出来，另一个有意思的多表代替密码是Hill密码，由数学家Lester Hill提出来的，其实就是利用了线性代数中的可逆矩阵，一个矩阵乘以它的逆矩阵得到单位矩阵，那么假设我们对密文每m个字母进行加密，那么将这m个字母在字母表中的序号写成矩阵形式设为P（如abc，[1,2,3])，密钥就是一个m阶的矩阵K，则C=P</em>K mod26，，解密的时候只要将密文乘上K的逆矩阵模26就可以了。该方法大大的增加了安全性。 上面的算法主要是多字母代替，现在再说说另一种多表代替的加密算法吧，其中最著名最简单的是vigenere密码，它的主要思想是对明文每m个字母进行加密，将每个字母加密，和Caesar算法一样，每个字母用后面的第k个字母来代替，只不过是m个字母中，每一个字母的k值不同，简单的说就是C=C0C1C2C3…=E(K,P)=(p0+k0）mod26,(p1+k1)mod26,(p2+k2)mod26…..但是这样的算法也是比较容易破解的，可以对相同字母的组合（如都是KATB）间隔数（存在偶然性，可以进行取舍），取公约数，那么m就是这个约数的某个因子，之后通过观察，如果长度为m，其实就是m个单表，进行分离就是m个单表分离，然后就很容易的破解了。。 另外一种加密手段，是选择一个与明文无关的，且与他长度一致的密钥，进行异或，解密的时候再一次异或就OK了，这也是基于两次异或同一个值，值不变的结论，大家可以尝试一下的~ 上面主要说的是替换技术，其实传统加密算法除了替换的技术，还有一种就是置换的技术了，简单的说就是将明文的序列打乱，比如栅栏技术，就是按照对角线的顺序写出明文，而按行的顺序读出作为密文。当然这种技术太简单了，更复杂一点的就是将消息一行行的写成矩阵块，然后按列读出，但是把列的次序打乱的，为了增加安全性，还可以多次置换来着。 传统加密高端一点的就是转轮机和隐写术了，转轮机是一种多重加密的技术，其主要的意义就是为DES加密提供了方向…隐写术是个神奇的东西，比如我们经常在电视剧中看到的隐形药水啥的…这些东西，就问度娘吧…..</p>
]]></content>
      <categories>
        <category>Theory</category>
      </categories>
      <tags>
        <tag>proof</tag>
      </tags>
  </entry>
  <entry>
    <title>匈牙利二分匹配</title>
    <url>/2013/04/28/%E5%8C%88%E7%89%99%E5%88%A9%E4%BA%8C%E5%88%86%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p>关于算法的说明，可以参看这个大牛的讲解，很详细： <a href="http://imlazy.ycool.com/post.1603708.html">http://imlazy.ycool.com/post.1603708.html</a> 直接上代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//从1到n编号</span></span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">if</span> (map[s][i] &amp;&amp; !visit[i])</span><br><span class="line">        &#123;</span><br><span class="line">            visit[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (pre[i]==<span class="number">0</span> || <span class="built_in">find</span>(pre[i]))</span><br><span class="line">             &#123;</span><br><span class="line">                 pre[i]=s;</span><br><span class="line">                 <span class="keyword">return</span> <span class="literal">true</span>;      </span><br><span class="line">             &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hungary</span><span class="params">()</span><span class="comment">//返回最大匹配数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="built_in">sizeof</span>(visit));</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(i)) ans++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>  好吧，具体的代码就应该是这样了，但是二分图是无向图吧。。。有向图，怎么破…</p>
]]></content>
      <categories>
        <category>ACMICPC</category>
      </categories>
  </entry>
  <entry>
    <title>匈牙利算法</title>
    <url>/2014/07/07/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>参见博客：<a href="http://blog.csdn.net/dark_scope/article/details/8880547%EF%BC%8C%E9%9D%9E%E5%B8%B8%E7%BB%99%E5%8A%9B%E7%9A%84%E8%AF%B4%E6%B3%95">http://blog.csdn.net/dark_scope/article/details/8880547，非常给力的说法</a> 关于二分图匹配，常用的结论如下：</p>
<ol>
<li><p>二分图的最小顶点覆盖 最小顶点覆盖要求用最少的点（X或Y中都行），让每条边都至少和其中一个点关联。 knoig定理:二分图的最小顶点覆盖数 = 二分图的最大匹配数（m）。</p>
</li>
<li><p>DAG图的最小路径覆盖 用尽量少的不相交简单路径覆盖有向无环图(DAG)G的所有顶点，这就是DAG图的最小路径覆盖问题。 结论：DAG图的最小路径覆盖数 = 节点数（n）- 最大匹配数（m）</p>
</li>
</ol>
<ol start="3">
<li>二分图的最大独立集 结论：二分图的最大独立集数 = 节点数（n）— 最大匹配数（m）</li>
</ol>
<p>匈牙利算法模板:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author:  xtestw</span></span><br><span class="line"><span class="comment"> * Created Time:  2014/7/6 21:55:04</span></span><br><span class="line"><span class="comment"> * File Name: hungry.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxint = <span class="number">-1u</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> g[<span class="number">1000</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="type">int</span> vis[<span class="number">1010</span>];</span><br><span class="line"><span class="type">int</span> pre[<span class="number">1010</span>];</span><br><span class="line"><span class="type">int</span> m,n1,n2;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="built_in">sizeof</span>(g));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(pre,<span class="number">-1</span>,<span class="built_in">sizeof</span>(pre));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">if</span> (m==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n1,&amp;n2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        g[a][b]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n2;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (g[x][i] &amp;&amp; !vis[i])&#123;</span><br><span class="line">            vis[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (pre[i]&lt;<span class="number">0</span> || <span class="built_in">find</span>(pre[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                pre[i]=x;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hungry</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(i))&#123;</span><br><span class="line">            ret++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="comment">// freopen(&quot;f:/in.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">         <span class="built_in">init</span>();</span><br><span class="line">         <span class="keyword">if</span> (m==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">hungry</span>()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACMICPC</category>
      </categories>
  </entry>
  <entry>
    <title>国内NextJs代理支持amp</title>
    <url>/2021/02/12/%E5%9B%BD%E5%86%85NextJs%E4%BB%A3%E7%90%86%E6%94%AF%E6%8C%81amp/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近学习了一下 nextjs，用这个写了个小网站 cushiwen.cn.  过程中发现 nextjs 天然支持 amp，虽然只有css-in-js的方式支持css， 但是还是很方便的，就尝试了一下。 发现过程中总是出现以下错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Error: Unable to fetch https://cdn.ampproject.org/v0/validator.js - connect ETIMEDOUT 172.217.27.129:443</span><br><span class="line">    at ClientRequest.&lt;anonymous&gt; (/Users/xxx/xtestw/xxx/fe-xxx/node_modules/next/dist/compiled/amphtml-validator/index.js:1:1159)</span><br><span class="line">    at ClientRequest.emit (node:events:329:20)</span><br><span class="line">    at TLSSocket.socketErrorListener (node:_http_client:478:9)</span><br><span class="line">    at TLSSocket.emit (node:events:329:20)</span><br><span class="line">    at emitErrorNT (node:internal/streams/destroy:188:8)</span><br><span class="line">    at emitErrorCloseNT (node:internal/streams/destroy:153:3)</span><br><span class="line">    at processTicksAndRejections (node:internal/process/task_queues:80:21)</span><br></pre></td></tr></table></figure>

<p>这就很尴尬了， 我自己架了个ss的代理，但是node本身的请求没有走代理，需要解决这个问题。</p>
<p>大概有几种解法吧：</p>
<ul>
<li>VPN的方式架梯子，成本有点高</li>
<li>Charles 全局代理捕获，自定义 response (未验证，理论可行)</li>
<li>node全局代理</li>
</ul>
<p>本文讨论最后一种的解法</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>查找了一些资料，通过<code>global-agent</code>来实现。其实现主要通过系统环境变量来实现的 主要步骤如下：</p>
<ol>
<li><p>安装 <code>global-agent</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yarn add <span class="variable language_">global</span>-agent</span><br></pre></td></tr></table></figure></li>
<li><p>添加引用</p>
<p>在需要的页面里面添加引用，我是在 _app.tsx 文件添加的</p>
</li>
</ol>
<span id="more"></span>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;global-agent/bootstrap&#x27;</span>;</span><br><span class="line"><span class="comment">// or:</span></span><br><span class="line"><span class="comment">// import &#123;bootstrap&#125; from &#x27;global-agent&#x27;;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>设置环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export GLOBAL_AGENT_HTTP_PROXY=http://127.0.0.1:8080</span><br></pre></td></tr></table></figure>

<p>如果指定部分域名不走代理的话，通过另外一个环境变量设置（因为我本地开了另外一个服务作为api接口, 所以这个接口不走代理）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export GLOBAL_AGENT_NO_PROXY=&#x27;*.test.com,test2.com,localhost:8888&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p>启动</p>
<p>需要找到next实际的启动地址，来启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node -r global-agent/bootstrap /Users/xxx/xtestw/yyy/fe-yyy/node_modules/next/dist/bin/next</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ul>
<li>其实通过改写 node 底层的 request 理论上也是可以的，不过对代码侵入太大了</li>
<li>参考：<a href="https://www.ctolib.com/gajus-global-agent.html">https://www.ctolib.com/gajus-global-agent.html</a></li>
</ul>
]]></content>
      <categories>
        <category>FE</category>
      </categories>
      <tags>
        <tag>FE</tag>
      </tags>
  </entry>
  <entry>
    <title>图论入门算法理解</title>
    <url>/2014/06/09/%E5%9B%BE%E8%AE%BA%E5%85%A5%E9%97%A8%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>1.Dijsktra 算法</p>
<p>​        Dijsktra算法是基于贪心的，从源点开始扩展，将当前已经是最短路的点加入集合中。dist[i]表示源点s到i的距离，那么初始的时候，找距离源点最近的一个点t0,那么dist[t0]必定是s到t0最短的距离，因为不可能通过其他的点转到t0再让t0最短了（这也是为什么Dijsktra不能处理负权边的原因），同理，扩展第二点的时候也是一样，因为 在扩展第二个点的时候，已经用 第一个点 优化了所有其他的点，那么最近的那个点，一定无法 通过剩余的其他的那个点来 优化自己的距离了，也就是说这个点dist[t1]必定是s到t1的最短路径。</p>
<p>2.floyd：</p>
<p>　　每个点而言，剩余的点的两两最短路，要么经过这个点，要么不经过这个点 ，只要看经过它是否能更短。从另一个角度来理解的话,c[i][j][k]表示i,j经过的中间节点最大的点的标号不超过k的最短路，那么dp的 转移方程就是c[i][j][k]=min(c[i][k][k-1]+c[k][j][k-1],c[i][j][k]).</p>
<span id="more"></span>

<p>3.Bellman-ford </p>
<p>​     进行n次按边松弛的操作，之所以是n次，因为每次松弛过程中，都能保证至少一个点获得了最短路，且每个点最多被经过1次，从DP角度来理解的话，d[k][v]=min(d[k-1][v]+e[u][v],d[k-1][v]),其中e[u][v]代表的是边，d[k][v]表示的是k次以内到达v的最短距离。</p>
<p>4.SPFA</p>
<p>　　最差的情况是n*(n-1)*e,每个点被松弛n-1次,dp[i]=min(dp[v]+mp[v][i],dp[i])</p>
]]></content>
      <categories>
        <category>ACMICPC</category>
      </categories>
      <tags>
        <tag>理论</tag>
      </tags>
  </entry>
  <entry>
    <title>母函数</title>
    <url>/2014/07/08/%E6%AF%8D%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>母函数的具体介绍见博客：<a href="http://www.wutianqi.com/?p=596">http://www.wutianqi.com/?p=596</a></p>
<p>其中第二类的说明中，对于为什么第一个表达式是(1+x^1+x^2+x^3….+x^n)，第二个表达式是(1+x^2+x^4+x^6)，没有解释清楚，我自己想了一下，做了hdu1389(<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1398)%E8%BF%99%E9%81%93%E9%A2%98%EF%BC%8C%E6%89%8D%E5%BD%BB%E5%BA%95%E6%98%8E%E7%99%BD%EF%BC%8C%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%8C%E6%8C%87%E7%9A%84%E6%98%AF%EF%BC%8C%E5%8F%AA%E7%94%A8%E4%BB%B7%E5%80%BC%E4%B8%BA1%E7%9A%84%E7%A1%AC%E5%B8%81%E7%BB%84%E6%88%90%E7%9A%84%E4%BB%B7%E5%80%BC%EF%BC%8C%E7%AC%AC%E4%BA%8C%E4%B8%AA%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%98%AF%E5%8F%AA%E7%94%A8%E4%BB%B7%E5%80%BC%E4%B8%BA2%E7%9A%84%E7%A1%AC%E5%B8%81%E8%83%BD%E8%8E%B7%E5%BE%97%E7%9A%84%E4%BB%B7%E5%80%BC%EF%BC%8C%E9%82%A3%E4%B9%88%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E7%AC%AC%E4%BA%8C%E4%B8%AA%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9B%B8%E4%B9%98%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%BE%97%E5%8F%AA%E6%9C%89%E4%BB%B7%E5%80%BC%E4%B8%BA1%E5%92%8C2%E4%B8%A4%E7%A7%8D%E7%A1%AC%E5%B8%81%E7%BB%84%E6%88%90%E7%9A%84%E4%BB%B7%E5%80%BC%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%8C%E4%B8%94%E7%B3%BB%E6%95%B0%E8%A1%A8%E7%A4%BA%E7%A7%8D%E7%B1%BB%E3%80%82%E8%BF%99%E6%A0%B7%E5%AD%90%E4%B9%9F%E5%B0%B1%E4%B8%8D%E9%9A%BE%E7%90%86%E8%A7%A31389%E5%AF%B9%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%94%B9%E5%8F%98%E4%BA%86%E3%80%82">http://acm.hdu.edu.cn/showproblem.php?pid=1398)这道题，才彻底明白，第一个表达式，指的是，只用价值为1的硬币组成的价值，第二个表达式是只用价值为2的硬币能获得的价值，那么第一个和第二个表达式相乘，就可以获得只有价值为1和2两种硬币组成的价值的情况，且系数表示种类。这样子也就不难理解1389对模板的改变了。</a></p>
<p>hdu 1389，可兼做模板：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Author:  xtestw</span><br><span class="line"> * Created Time:  2014/7/8 7:32:31</span><br><span class="line"> * File Name: 1289.cpp</span><br><span class="line"> */</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxint = -1u&gt;&gt;1;</span><br><span class="line">int c1[400],c2[400];</span><br><span class="line">int main() &#123;</span><br><span class="line">#ifndef ONLINE_JUDGE</span><br><span class="line">   freopen(&quot;f:/in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">#endif</span><br><span class="line">   int n;</span><br><span class="line">   while (scanf(&quot;%d&quot;,&amp;n) &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            c1[i]=1;</span><br><span class="line">            c2[i]=0;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=2;i*i&lt;=n;i++)//i*i表示的就是第i个表达式是由价值为i*i的硬币的情况</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=0;j&lt;=n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int k=0;k+j&lt;=n;k+=i*i)</span><br><span class="line">                &#123;</span><br><span class="line">                    c2[j+k]+=c1[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">for(int j=0;j&lt;=n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                c1[j]=c2[j];</span><br><span class="line">                c2[j]=0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;c1[n]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> hdu 1171利用母函数求解的代码：</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Author:  xtestw</span><br><span class="line"> * Created Time:  2014/7/8 8:47:03</span><br><span class="line"> * File Name: 1171.cpp</span><br><span class="line"> */</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxint = -1u&gt;&gt;1;</span><br><span class="line">int c1[300000];</span><br><span class="line">int c2[300000];</span><br><span class="line">int v[1000];</span><br><span class="line">int w[1000];</span><br><span class="line">int main() &#123;</span><br><span class="line">#ifndef ONLINE_JUDGE</span><br><span class="line">   freopen(&quot;f:/in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">#endif</span><br><span class="line">   int n;</span><br><span class="line">   while (scanf(&quot;%d&quot;,&amp;n) &amp;&amp; n&gt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        int sum=0;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;v[i],&amp;w[i]);</span><br><span class="line">            sum+=v[i]*w[i];</span><br><span class="line">        &#125;</span><br><span class="line">        memset(c2,0,sizeof(c2));</span><br><span class="line">        memset(c1,0,sizeof(c1));</span><br><span class="line">        for(int i=0;i&lt;=w[1];i++)</span><br><span class="line">        &#123;</span><br><span class="line">            c1[v[1]*i]=1;</span><br><span class="line">            c2[i]=0;</span><br><span class="line">        &#125;</span><br><span class="line">        int max=0;</span><br><span class="line">        for(int i=2;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=0;j&lt;=sum;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int k=0;k+j&lt;=sum &amp;&amp; k&lt;=w[i]*v[i];k+=v[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    c2[j+k]+=c1[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j=0;j&lt;sum;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                c1[j]=c2[j];</span><br><span class="line">                c2[j]=0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=sum/2;i&gt;=0;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if (c1[i])</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;sum-i&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACMICPC</category>
      </categories>
      <tags>
        <tag>proof</tag>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-代理模式</title>
    <url>/2014/09/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>在实际开发的时候，我们同样的一个对象，对于不同的客户，可能能够调用的方法是不一样的，就是权限的控制，这个时候，对象的方法都应该是public，那么就要给对象加上一层，通过客户的类型，决定是否可以访问，也就是说，客户不直接访问对象，而是访问给对象加上的这一层，就是代理层。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface T1&#123;</span><br><span class="line">    public void method();</span><br><span class="line">&#125;;</span><br><span class="line">public class Item implements T1&#123;</span><br><span class="line">    public void method();</span><br><span class="line">&#125;</span><br><span class="line">public class ItemProxy implements T1&#123;</span><br><span class="line">    Item item;</span><br><span class="line">    Client client;</span><br><span class="line">    public ItemProxy(Client c)&#123;</span><br><span class="line">        this.Client=c;</span><br><span class="line">        this.item=new item();</span><br><span class="line">    &#125;</span><br><span class="line">    public void method()&#123;</span><br><span class="line">        if (client,allow())&#123;    </span><br><span class="line">            item.method1();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Client&#123;</span><br><span class="line">    T1 t;</span><br><span class="line">    public Client()    </span><br><span class="line">    &#123;</span><br><span class="line">        t=new ItemProxy(this);</span><br><span class="line">    &#125;</span><br><span class="line">    public void method1()</span><br><span class="line">    &#123;    </span><br><span class="line">        t.method();    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以在代理类中，控制对象的访问了，当然代理模式实现方式还有很多种，（远程代理管理客户和远程对象的交互，虚拟代理控制访问实例化开销大的对象，保护代理基于调用者控制对对象方法的访问），上面只是其中的一种方式，代理模式的定义如下：</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">代理模式：为另一个对象提供一个替身或占位符以访问这个对象。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-单件模式</title>
    <url>/2014/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BB%B6%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>工程中，某些对象我们只需要一个，比如线程池，缓存，对话框等的对象，我们通常的做法是可以定一个全局静态变量，然后通过程序初始化的时候就实例化他们，然后直接调用这个全局变量，但是这样有个问题，如果我的这个对象消耗的资源很多，而有的时候，我的程序在运行过程中又没用到这个对象，岂不是浪费了很多资源。通常的做法就是定义全局静态变量的时候，不初始化他，而是在调用过程中实例化，这样的话，对于全局变量的实例化，我们就要判断这个变量是否已经实例化了，如果实例化了的吧，我们就不对它进行实例化，所以代码如下：</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class A</span><br><span class="line">&#123;</span><br><span class="line">    private A()&#123;&#125;</span><br><span class="line">    public static A cla;</span><br><span class="line">    public static A getInstance()</span><br><span class="line">    &#123;</span><br><span class="line">        if (cla == null)&#123;</span><br><span class="line">            cla=new A();</span><br><span class="line">        &#125;</span><br><span class="line">        return cla;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的A的构造器是私有的，这样子可以有效的保证A这个类不会再外部被实例化，从而保证他的唯一性，我们通过getInstance来获取A的全局唯一变量cla，这样就有效的解决了上面这个问题，但是问题又来了，多线程访问getInstance()的时候？cla完全可能出现实例化一次之后又被实例化，怎么办？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class A</span><br><span class="line">&#123;</span><br><span class="line">    private A()&#123;&#125;</span><br><span class="line">    public static A cla;</span><br><span class="line">    public static synchronized A getInstance()</span><br><span class="line">    &#123;</span><br><span class="line">        if (cla == null)&#123;</span><br><span class="line">            cla=new A();</span><br><span class="line">        &#125;</span><br><span class="line">        return cla;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们就为A获取实力的方法getInstance增加一个同步锁来保证方法只能被唯一访问，可是，同步锁势必会降低运行效率，而且我们发现，事实上，也就是第一次实例化的时候会出现问题需要同步锁，以后再需要获取这个对象的时候完全不需要，如果我们频繁的获取对象的话，效率的影响就会相当大。回到最开始的做法?设置全局变量，程序运行的时候就实例化对象？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class A</span><br><span class="line">&#123;</span><br><span class="line">    private A()&#123;&#125;</span><br><span class="line">    public static A cla = new A();</span><br><span class="line">    public static synchronized A getInstance()</span><br><span class="line">    &#123;</span><br><span class="line">        return cla;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个确实是种方法，但始终不是最好的方法，我们想到，之前所说的，只有在实例化的时候才需要同步锁，那么我们就想到采用双重检查加锁的方法，只在实例化的时候加锁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class A</span><br><span class="line">&#123;</span><br><span class="line">    private A()&#123;&#125;</span><br><span class="line">    public volatile static A cla;</span><br><span class="line">    public static A getInstance()</span><br><span class="line">    &#123;</span><br><span class="line">         if (cla == null)&#123;</span><br><span class="line">            synchronized(A.class)&#123;</span><br><span class="line">                if (cla==null)&#123;</span><br><span class="line">                    cla=new A();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        return cla;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中volatile的关键字是确保多线程在cla变量初始化的时候，正确的处理cla变量。(volatile用在多线程，同步变量。 线程为了提高效率，将某成员变量(如A)拷贝了一份（如B），线程中对A的访问其实访问的是B。只在某些动作时才进行A和B的同步。因此存在A和B不一致的情况。volatile就是用来避免这种情况的。volatile告诉jvm， 它所修饰的变量不保留拷贝，直接访问主内存中的（也就是上面说的A))</p>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-工厂模式</title>
    <url>/2014/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>在面向对象的编程中，我们常常会用到new这个关键字，同时，面向对象可以实现多态，这样的话，我们常常就会用父类或者接口定义一个变量，在用到这个变量的时候，再new一个具体的对象，但是有的时候，这个new的对象不是确定的，可能是要根据不同的场景，new出不同的子类，这个很简单的就可以通过if 或者switch来判断实现，但是，这样子以来的话，如果在很多个地方都出现了这种情况，岂不是都要在这些个地方来写这些一样的代码？这样真的好么？</p>
<p>工厂模式就是用来解决这种对象的生成的办法。工厂模式主要分为3种：简单工厂，工厂方法，抽象工厂。</p>
<span id="more"></span>

<p>简单工厂：</p>
<pre><code> 简单工厂其实就是将对象的生成单独抽象出来成为一个单独的类，这样子就可以在生成对象的时候，直接调用这个类的create的方法来返回一个对象。有的时候，这个生成类的方法可以写成静态的，也就是所说的静态工厂.
</code></pre>
<p>但是有的时候，这个类生成方法，对于不同的类，生成的过程是不一样的，比如A类，只需要1、2、3这3个类，B类只会生成4,5，6这3个类，如果用简单工厂的话，一是会显得很冗余，逻辑处理很烦，二是每多一个if的判定都会降低效率。我们就把对应的工厂方法放到了不同的类中</p>
<p>工厂方法:</p>
<pre><code>  工厂方法就是不把具体的生成类的过程单独抽象成一个类，而是在A,B这两个父类中，定义一个抽象方法createXX（），然后在A，B这两个子类中针对自己实现createXX（）方法。
</code></pre>
<p>抽象工厂：</p>
<p>抽象工厂可以针对一组对象的生成，比如A类B类都要有一个1 2 3 这3个类，这3个类是3种类别是一个父类，又分别分为几种，1类中有1a,1b,1c,2类3类中一样，我们的A对象需要的是1a,2b,3a,B对象需要的是1b,2a,3c，那么我们就定义个抽象的工厂类，分别分为create1(),create2(),creat3()，3个方法，然后继承过来两个工厂类，分别返回A,B类需要的工厂，我们在A类,B类的构造函数中注入这两个工厂实现类，就可以调用他们的create1,create2,create3的方法来获取自己想要的1,2,3这3种类了。</p>
<p>设计原则：</p>
<p>工厂模式中用到了一个设计原则，依赖倒置原则：</p>
<p>依赖倒置原则：依赖抽象，不要依赖具体类<br>其实我的感觉就是定义变量的时候定义父类，而不是具体子类，对象的构建就需要动态的生成，要完成依赖倒置，可以依据下面的方法：</p>
<p>变量不可以持有具体类的引用<br>不要让类派生自具体类<br>不要覆盖基类中已实现的方法</p>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-模板方法</title>
    <url>/2014/09/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>前面学习过了策略模式，策略模式是对一类的算法进行封装，利用组合，算法之间可以互相替换，但是这个是针对算法过程不是一样的算法。但是如果一系列的算法的步骤都是一样的，且算法的很多过程都是一样的处理，那么，用策略模式的话，会导致算法的重用不高，我们采用模板方法来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">模板方法模式：在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class CAL&#123;</span><br><span class="line">    public final void algorithm()</span><br><span class="line">    &#123;</span><br><span class="line">        A1();</span><br><span class="line">        A2();</span><br><span class="line">        if (Judge())</span><br><span class="line">            A3();</span><br><span class="line">        A4();</span><br><span class="line">    &#125;</span><br><span class="line">    public void A1()&#123;</span><br><span class="line">        //实现</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">    public  void A2()&#123;</span><br><span class="line">        //实现</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract void A3()&#123;&#125;</span><br><span class="line">    public abstract void A4()&#123;&#125;</span><br><span class="line">    public boolean Judge()&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中模板类是一个抽象类，其中算法是确定了的，A1，A2是公共的方法，所有的子类都是一样的，A3，A4是子类自己实现的不一样的函数，定义为抽象方法，子类实现，而Judge方法被成为钩子，默认返回true，而子类可以重写这个方法，这样就能让子类拥有自己的方法。但是这个也反应了模板方法的一个缺点，就是与策略模式相比，弹性不足。</p>
<span id="more"></span>

<p>设计模式-好莱坞模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">好莱坞模式：别调用我们，我们会调用你。</span><br></pre></td></tr></table></figure>

<p>允许低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎样使用这些低层组件。</p>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-状态模式</title>
    <url>/2014/09/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>状态模式是针对系统的状态转换的，其主要的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">状态模式：允许对象在内部状态改变时改变他的行为，对象看起来好像修改了它的类。</span><br></pre></td></tr></table></figure>

<p>为了方便状态转移 我们为状态定义一个通用的接口，然后每一种状态都实现这个接口，而在系统类中，通过构造函数，将系统本身传入状态类中，这样，每一种状态的改变，都可以在自己类的内部完成，同时提高了可扩展性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface State&#123;</span><br><span class="line">    public void des();</span><br><span class="line">    public void action();</span><br><span class="line">&#125;</span><br><span class="line">public class State1 implements State&#123;</span><br><span class="line">    Sys sys;</span><br><span class="line">    public Sate1(Sys s)</span><br><span class="line">    &#123;</span><br><span class="line">        this.sys=sys;</span><br><span class="line">    &#125;</span><br><span class="line">    public void des()&#123;</span><br><span class="line">        .../ implements</span><br><span class="line">    &#125;</span><br><span class="line">    public void action()&#123;</span><br><span class="line">        .../ change the state</span><br><span class="line">        sys.setState(s.getState2());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class State2 implements State&#123;</span><br><span class="line">    Sys sys;</span><br><span class="line">    public Sate2(Sys s)</span><br><span class="line">    &#123;</span><br><span class="line">        this.sys=sys;</span><br><span class="line">    &#125;</span><br><span class="line">    public void des()&#123;</span><br><span class="line">        .../ implements</span><br><span class="line">    &#125;</span><br><span class="line">    public void action()&#123;</span><br><span class="line">        .../ change the state</span><br><span class="line">        sys.setState(s.getState1());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Sys &#123;</span><br><span class="line">    private State1 state1;</span><br><span class="line">    private State2 state2;</span><br><span class="line">    private State state;//record the system&#x27;s state</span><br><span class="line">    ....//state1 &amp; state2&#x27;s setter &amp; getter</span><br><span class="line">    public Sys(State state)</span><br><span class="line">    &#123;</span><br><span class="line">        this.state=state;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setState(State state)</span><br><span class="line">    &#123;    </span><br><span class="line">        this.state=state;</span><br><span class="line">    &#125;    </span><br><span class="line">    public void aciton()</span><br><span class="line">    &#123;</span><br><span class="line">        state.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>虽然在实现上 状态模式和策略模式以及模板方法有些相似 但是几个设计模式完全不一样，策略模式是将可以互换的行为封装起来，然后使用委托的方法决定使用哪一个行为，模板方法则是由子类决定具体的如何实现算法中的某些步骤，而算法的流程是给定的，而状态模式则封装的是基于状态的行为，并将行为委托到当前状态，由当前状态来决定具体行为。</p>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-策略模式</title>
    <url>/2014/08/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>​ 在实际开发过程中，经常会发生这样的一件事，我们需要实现一系列的功能，这些功能在逻辑上是可以抽象成一样的方法，不同的实现，也就是多态，有一种解决方法是，设计一个基类，然后我们定义一些方法，然后继承这个类，设计不同的子类，不同的实现，这样子我们就可以定义基类来调用子类的方法，实现多态，这种方法一定程度上是实现了代码复用。</p>
<p>​ 但是会有一个问题，假设，基类BaseClass具有一个方法，他们的子类都具有两个方法A和B，其中方法A的实现，所有的子类都一样，很明显A的实现方法是放在基类中实现的，如果B的方法每个子类的实现都不是一样的，那么毫无疑问的是我们会在每个子类中重写B的实现。这些都是显而易见的，但是某一天需求变了，BaseClass的子类childClass1，childClass2的B方法的实现是完全一样的，childClass3，childClass4的B方法的实现也是一样的，如果我们再在每个子类中实现这个方法，很明显，代码复用很不完美。也许我们会这样子解决这个问题:</p>
<span id="more"></span>

<p>​ 在现有的基类和子类中再添加一层，分别为childClass1，childClass2添加由BaseClass继承而来的一个父类，使得这两个子类从新增的这个类中继承，而他们的B方法的实现放在这个新增的类中，同样的操作对childClass3,childClass4进行。</p>
<p>​ 这个方法一定程度上是解决了上面的问题，但是新的问题又出现了，如果再来一个方法C，childClass2和childClass3的方法C的实现又是一样的，那又该怎么办？显然我们的设计很有问题。此时我们就需要题目中所说的设计模式—-策略模式。</p>
<pre><code>  策略模式的概念太过抽象，我们先看看如何解决上诉问题:
</code></pre>
<p>​ 我们通过接口来解决这些变化的方法，我们针对可能会变化的B,C两个方法分别定义一个接口interfaceB，interfaceC,针对childClass1,childClass2我们定义一个类classB1用他们的方法B来实现interfaceB，同理我们生成classB2,classC1,classC2,classC3分别对应不同的方法B和C的实现，这样子，我们只要在基类中定义一个B，C类型为interfaceB，interfaceC的方法引用变量和两个引用对应的setter方法，就可以在子类的构造函数中通过setter方法定制属于自已的方法B,C了，从而很好的实现了代码复用的同时，降低了耦合性，增强了可扩展性。</p>
<pre><code> 我们将这种方法B和C称为策略，那么我们的策略模式，就是针对每一类方法我们定义一套策略，这一套策略是对一类方法的不同实现，他们之间可以互相替换，这种方法可以让算法的变化独立在了使用算法的客户。

 这一章里面，也抽象出了下面的3种设计原则：
</code></pre>
<p>1、封装变化<br>2、多用组合，少用继承<br>3、针对接口编程，不针对实现编程</p>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-装饰者模式</title>
    <url>/2014/08/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>​     这一章看完之后，我感觉，装饰者模式就是对类继承的一种递归调用式的组合应用，很好的是实现了开闭原则，可以有效的扩展应用程序。比如书中的例子，有几种饮料，每种饮料的价格已经知道了，但是我们又有很多种的调料，每种调料也有它的价格，我们现在需要是在饮料中加调料，那么这样一来，饮料的售价就会变化，如何来描述这种售价呢？如果通过对调料种类的组合来定义若干的类，肯定是非常愚蠢的行为。</p>
</blockquote>
<blockquote>
<p>​     通过装饰者模式，就能很好的解决这个问题，我们将这些类分为装饰类（调料），待装饰类（饮料）两种，这两种类继承同一个父类，不同的是装饰类中的构造函数有一个父类引用的构造函数，这样子就可以递归调用构造函数来进行 装饰了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class A extends BaseClass&#123;</span><br><span class="line">    </span><br><span class="line">    public string who()</span><br><span class="line">    &#123;</span><br><span class="line">        return &quot;A&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int cost()</span><br><span class="line">    &#123;</span><br><span class="line">        return 5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义一个待装饰类A，再定义几个装饰类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class decorator1 extends BaseClass&#123;</span><br><span class="line">    BaseClass baseClass;    </span><br><span class="line">    public decorator1(BaseClass t）</span><br><span class="line">    &#123;</span><br><span class="line">        this.baseClass = t;</span><br><span class="line">    &#125;</span><br><span class="line">    public string who()</span><br><span class="line">    &#123;</span><br><span class="line">        return baseClass.who()+&quot;,decoratro1&quot;;    </span><br><span class="line">    &#125;    </span><br><span class="line">    public int cost()</span><br><span class="line">    &#123;</span><br><span class="line">        return baseClass.cost()+10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class decorator2 extends BaseClass&#123;</span><br><span class="line">    BaseClass baseClass;    </span><br><span class="line">    public decorator2(BaseClass t）</span><br><span class="line">    &#123;</span><br><span class="line">        this.baseClass = t;</span><br><span class="line">    &#125;</span><br><span class="line">    public string who()</span><br><span class="line">    &#123;</span><br><span class="line">        return baseClass.who()+&quot;,decoratro2&quot;;    </span><br><span class="line">    &#125;    </span><br><span class="line">    public int cost()</span><br><span class="line">    &#123;</span><br><span class="line">        return baseClass.cost()+20;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们在用decorator1 和decorator2 来装饰A的时候，就有了很犀利的调用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A  a;</span><br><span class="line">a=new decorator1(a);</span><br><span class="line">a=new deocorator2(a);</span><br><span class="line">system.out.println(a.who());</span><br><span class="line">system.out.println(a.cost());</span><br></pre></td></tr></table></figure>

<p>这样子 输出就是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A,decorator1,decorator2</span><br><span class="line">35</span><br></pre></td></tr></table></figure>

<p>实际的调用过程就是一个递归的过程。</p>
<p>装饰者模式的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">装饰者模式：动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更具有弹性的替代方案</span><br></pre></td></tr></table></figure>

<p>其中用到的设计原则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开闭原则：对扩展开放，对修改关闭</span><br></pre></td></tr></table></figure>

</blockquote>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-观察者模式</title>
    <url>/2014/08/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>在项目设计阶段，处理一对多的依赖关系类的时候，我们需要降低代码的耦合性从而增强可扩展性，比如一个班级，班主任老师和学生的关系，对于学校的通知，必定不会是学生没事的时候就问一下班主任”学校有通知没啊？”（铁定会把班主任搞毛的），明智的做法则是等着班主任在班级里面通知（对于学校的通知，班主任不会不通知学生的）,在这个关系里，班主任就是所谓的被观察者，而学生则是观察者，也就是所谓的观察者模式：</p>
<blockquote>
<p>观察者模式：定义了对象之间的一对多的依赖，这样一来，当一个对象改变状态的时候，他的所有依赖都会收到通知并自动更新</p>
</blockquote>
<span id="more"></span>

<p>对于观察者模式中所说的通知，就是在被观察者的状态改变的时候，能够让所有观察者根据这种变化作出反应,对于被观察者，他的手里应该有一张观察者的名单，只有这样，才能在状态改变的时候，给出观察者通知，就如上面的例子，班主任只有知道他们班有哪些学生，才能通知到位，当然有的时候，有的学生并不想知道学校的那些通知，那么他就要从老师那边把自己的名字从通知名单中删除掉，但是如果有一天他又想听了，那么对名单还有提供增加一个观察者的名单，之所以命名为观察者和被观察者，而不是通知者和被通知者，就是因为观察者有是否观察的主动权，按照前面一章所讲的，针对接口编程，我们就可以设计出一个被观察者的接口:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface Observerable&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">addObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">deleteObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">notifyChanged</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于观察者，他的职责就是等着被观察者的更新，然后更新自己的状态，我们也设计出他的接口</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface Observer&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">update</span><span class="params">(object[] data)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显的观察者在运行的时候，必须知道知道自己的观察对象是谁，所以在观察者类中应该有个变量记录被观察者：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Observer1</span> implements Observer&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Observerable subject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Observer1</span><span class="params">(Observerable subject)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject=subject;</span><br><span class="line">        subject.<span class="built_in">addObserver</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">update</span><span class="params">(object\[\] data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ........</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在java的java.until包中 也提供了这两个接口，但是与我们不同的是，他的被观察者ObserverAble不是一个接口而是一个类，其中提供了setChanged()的这个函数，这个函数的作用就是设定changed的值从而决定是否通知所有的观察者是否更新，因为有些变化并不一定是要通知观察者，比如学校专门给老师发的工资调整的通知，这个真的有必要告诉学生么？(另外需要注意的是，java这个ObserverAble类，提供的setChanged方法是protected的，所以你要是用它，就必须继承这个类，如果你要同时继承另外一个类的话，….) 另一个问题，学生向学校提交了一份申请，但是，老师那边久久没有回应，怎么办，学生一直等下去么？肯定不行的，必定是要主动向老师询问结果的，这也就意味着，我们的观察者可以主动的从被观察者那边获取数据，那么观察者就必须提供对应数据的get方法。 另外这一章中也提到了一个新的设计原则：</p>
<blockquote>
<p>为交互对象间的松耦合设计而努力</p>
</blockquote>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-迭代器模式和组合模式</title>
    <url>/2014/09/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>1.迭代器模式完成的功能是和迭代器一样的，封装了对对象的顺序遍历，因为子类的对象集合的存储方式可能并不一致。但是存储的对象是一致的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public classItem&#123;</span><br><span class="line">    .....//各种属性</span><br><span class="line">&#125;</span><br><span class="line">public class Set1&#123;</span><br><span class="line">    item[] items;</span><br><span class="line">    ...</span><br><span class="line">    public Iterator createIterator()&#123;</span><br><span class="line">        return new ItemIterator(items);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Set2&#123;</span><br><span class="line">    ArrayList items;</span><br><span class="line">    ...</span><br><span class="line">    public Iterator createIterator()&#123;</span><br><span class="line">        return  items.iterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ItemIterator implements Iterator&#123;</span><br><span class="line">    Item[] items;</span><br><span class="line">     int position;</span><br><span class="line">    public ItemIterator(Item[] items)</span><br><span class="line">    &#123;</span><br><span class="line">        this.items=items;</span><br><span class="line">        position=0;</span><br><span class="line">    &#125;</span><br><span class="line">    public Object next()</span><br><span class="line">    &#123;</span><br><span class="line">        Item i=items[position];</span><br><span class="line">        position=position+1;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean hasNext()</span><br><span class="line">    &#123;</span><br><span class="line">        if (position&gt;=items.lenght || items[position]==null)</span><br><span class="line">            return false;</span><br><span class="line">        else</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方法，我们就可以通过自己定义的一个迭代器来访问数组，同时通过createIterator的方法来顺序遍历存储结构不一样的Set1和Set2中item对象。所以迭代器模式就是:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">迭代器模式：提供一种方法顺序访问一个聚合对象中的各种元素，而又不暴露其内部的表示。</span><br></pre></td></tr></table></figure>

<p>2.组合模式</p>
<p>组合模式其实就是整体与部分的一个关系，其实就是一个树形结构，根节点由他的子节点组合而成，而子节点又有自己的子节点来组合而成，所以组合模式的定义如下：</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">组合模式：允许你将对象组合成树形结构来表现“整体/部分”的层次结构，组合能让客户以一致的方法处理个别对象以及对象组合。</span><br></pre></td></tr></table></figure>

<p>现在我们需要对组合模式下的对象这棵进行遍历怎么办？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class ItemComponent&#123;</span><br><span class="line">    ....//方法</span><br><span class="line">    public void method1()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public classItem extends ItemComponent&#123;</span><br><span class="line">    .....//各种属性</span><br><span class="line">    public void method1()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;leaf&quot;);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">public class Set1 extends ItemComponent&#123;</span><br><span class="line">    item[] items;</span><br><span class="line">    ...</span><br><span class="line">    public Iterator Iterator()&#123;</span><br><span class="line">        return new ItemIterator(items);</span><br><span class="line">    &#125;</span><br><span class="line">    public void method1()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;not leaf&quot;);</span><br><span class="line">        Iterator iterator=itemComponent.iterator();//重写</span><br><span class="line">        while (iterator.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            ItemComponent t=(ItemComponent) iterator.next();</span><br><span class="line">            t.method1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Set2 extends ItemComponent&#123;</span><br><span class="line">    ArrayList items;</span><br><span class="line">    ...</span><br><span class="line">    public Iterator Iterator()&#123;</span><br><span class="line">        return  items.iterator();</span><br><span class="line">    &#125;</span><br><span class="line">        public void method1()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;not leaf&quot;);</span><br><span class="line">        Iterator iterator=itemComponent.iterator();//重写</span><br><span class="line">        while (iterator.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            ItemComponent t=(ItemComponent) iterator.next();</span><br><span class="line">            t.method1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这种方式是一种通过递归的方式来实现全部遍历的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ItemIterator implements Iterator&#123;</span><br><span class="line">    stack stack = new Stack();</span><br><span class="line">    public ItemIterator(Iterator iter)</span><br><span class="line">    &#123;</span><br><span class="line">        stack.push(iter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     public Object next()</span><br><span class="line">    &#123;</span><br><span class="line">        if (hasNext())&#123;</span><br><span class="line">            Iterator iterator=(Iterator)stack.peek();</span><br><span class="line">            ItemComponent t=(ItemComponent) iterator.next();</span><br><span class="line">            if (t instanceof Set1)</span><br><span class="line">            &#123;</span><br><span class="line">                stack.push(t.createIterator());    </span><br><span class="line">            &#125;</span><br><span class="line">            return t;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean hasNext()</span><br><span class="line">    &#123;</span><br><span class="line">        if (stack.empty())&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            Iterator iterator=(Iterator) stack.peek();</span><br><span class="line">            if (!iterator.hasNext())&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                return hasNext();</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在定义的这种方式，是通过迭代器用栈模拟递归的一种方式。</p>
<p>3。设计模式-职责单一</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单一责任： 一个类应该只有一个引起变化的原因。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-适配器模式和外观模式</title>
    <url>/2014/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>1.适配器模式</p>
<p>适配器模式是针对接口不一时处理的情况，比如我的类的参数是IInterface1，但是我现在想要调用IInterface2接口的函数，怎么办呢？就是用适配器来解决这个问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface IInterface1()&#123;</span><br><span class="line">    public void method1();</span><br><span class="line">&#125;</span><br><span class="line">public interface IInterface2()&#123;</span><br><span class="line">    public void method2();</span><br><span class="line">&#125;</span><br><span class="line">public class adapter implements IInterface1&#123;</span><br><span class="line">    IInterface2 v;</span><br><span class="line">    public adapter(IInterface2 t)&#123;</span><br><span class="line">        this.v=t;</span><br><span class="line">    &#125;</span><br><span class="line">    public void method1()&#123;</span><br><span class="line">        v.method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们调用IIterface2的method1的方法的时候，就是可以直接构造一个适配器来完成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class A&#123;</span><br><span class="line"></span><br><span class="line">    public void method3(IInterface1 t)</span><br><span class="line">    &#123;</span><br><span class="line">        t.method1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] arg)</span><br><span class="line">    &#123;</span><br><span class="line">        (new A()).method3(new adapter(claimplementInterfce2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中claimplementInterface2是实现Interface2的一个类的实例。这种适配器的方法被称作为对象适配器，还有一种适配器，叫做类适配器，是基于类的多继承的，其中适配器继承自要适配的两个类，用其中一个类的方法调用另一个类，思想是一致的，不过java不支持多继承，所以也就是只能用对象适配器。</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">适配器模式：将一个类的接口，转换成客户期望的另一个接口，适配器让原本接口不兼容的类可以合作无间</span><br></pre></td></tr></table></figure>

<p>2.外观模式</p>
<p>  外观模式，其实就是对一个子系统的方法进行整理，对外公开一些方法，方便外部的调用，但是并不是对这些类的一个封装，只是提供了一个简单的接口，用户如果觉得没什么用出，可以直接调用子系统的方法，而且，一个子系统可以有很多个外观。所以外观模式的定义如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">外观模式：提供一个统一的接口，用来访问子系统的一群接口。外观定义了一个高层接口，让子系统更容易使用。</span><br></pre></td></tr></table></figure>

<p>比如我们用电脑，怎么开机，怎么关机呢：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UseComputer&#123;</span><br><span class="line">    ZHUJI zhuji;</span><br><span class="line">                XIANSHIQI xianshiqi;</span><br><span class="line">            ...</span><br><span class="line">    public UseComputer(ZHUJI zhuji,XIANSHIQI xianshiqi,....)</span><br><span class="line">    &#123;</span><br><span class="line">        this.zhuji=zhuji;</span><br><span class="line">        this.xianshiqi=xianshiqi;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">    public void guanji()</span><br><span class="line">    &#123;</span><br><span class="line">        zhuji.off();</span><br><span class="line">        xianshiqi.off();</span><br><span class="line">    &#125;</span><br><span class="line">    public void kaiji()</span><br><span class="line">    &#123;</span><br><span class="line">        xianshiqi.on();</span><br><span class="line">        zhuji.on();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就直接提供给用户开机和关机的操作了，而不用用户自己去调用开机关机的一系列的方法了。</p>
<p>3.设计原则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最少知识原则：只和你的密友谈话</span><br></pre></td></tr></table></figure>

<p>需要做到这个原则，建议只调用一下的范围的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对象本身</span><br><span class="line">被当作方法的参数而传递进来的对象</span><br><span class="line">此方法所创建或实例化的任何对象</span><br><span class="line">对象的任何组组件</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>领域划分的一些思考</title>
    <url>/2025/04/22/%E9%A2%86%E5%9F%9F%E5%88%92%E5%88%86%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h3 id="为什么要划分"><a href="#为什么要划分" class="headerlink" title="为什么要划分"></a><strong>为什么要划分</strong></h3><p>对于一个业务系统，以业务为核心，随着业务发展，在业务和工程侧必然导致以下2种情况的发生</p>
<p><img src="/images/%E6%88%91%E7%9A%84%E9%A2%86%E5%9F%9F%E8%A7%82-%E5%85%B3%E4%BA%8E%E9%A2%86%E5%9F%9F%E5%88%92%E5%88%86/out.png" alt="img"></p>
<p>最终导致一个问题：业务支持效率降低</p>
<p>解决的方法： <strong>拆</strong></p>
<p>原则：组织/系统围绕业务的发展进行迭代升级</p>
<p>目标：既需要解决当下业务支持效率降低的问题，又能够很好的支撑业务长期稳定发展。 </p>
<p>对于业务初期，通常会采用大的单体工程方式支持早期的快速发展，但是明显的业务膨胀带来代码量的急剧攀升，团队规模的扩大带来协作风险的增加，很难继续支持业务高速发展，故需要进行相应的领域拆分，以保持对业务的迭代的高效支撑，而 DDD 提供了一种从业务出发的建模方法，能很好满足我们的目标要求，故通过领域化，分而治之，进行我们的系统建设。</p>
<span id="more"></span>
<p><img src="/images/%E6%88%91%E7%9A%84%E9%A2%86%E5%9F%9F%E8%A7%82-%E5%85%B3%E4%BA%8E%E9%A2%86%E5%9F%9F%E5%88%92%E5%88%86/out-20240128124119498.png" alt="img" style="zoom:50%;" /><img src="/images/%E6%88%91%E7%9A%84%E9%A2%86%E5%9F%9F%E8%A7%82-%E5%85%B3%E4%BA%8E%E9%A2%86%E5%9F%9F%E5%88%92%E5%88%86/out-20240128124142246.png" alt="img" style="zoom:50%;" /></p>
<h3 id="怎么划分"><a href="#怎么划分" class="headerlink" title="怎么划分"></a><strong>怎么划分</strong></h3><p><img src="/images/%E6%88%91%E7%9A%84%E9%A2%86%E5%9F%9F%E8%A7%82-%E5%85%B3%E4%BA%8E%E9%A2%86%E5%9F%9F%E5%88%92%E5%88%86/out-20240128124254574.png" alt="img"></p>
<p><strong>目的：</strong>保持对业务的迭代的高效支撑</p>
<p><strong>目标：</strong></p>
<p>对于领域的划分，一定是围绕着业务进行的，而最终的划分一定满足4个要求</p>
<ul>
<li>全面：能够涵盖直播全部的业务，足够支撑直播大域所需能力</li>
<li>清晰：领域职责和边界足够清晰，领域内实体和能力的定义足够明确</li>
<li>应变：稳定支撑现有业务的同时，能够高效的应变业务的变化，维持其迭代效率</li>
<li>粒度：符合当前业务&amp;团队规模</li>
</ul>
<p><strong>原则：</strong></p>
<ul>
<li><p>领域化原则</p>
<ul>
<li>互斥——垂直领域互斥、子领域间互斥<strong>：</strong>一级领域参考电商线 要互斥（如领域：营销、交易、物流、售后），二级领域参考领域内模块划分 要互斥（如商品领域内的二级子域，包括商品、库存、价格），保证外部边界清晰；</li>
<li>分层——领域内上下分层、并保持一致：某一个领域在开发服务的分层次对应，包括API/Gateway接入层、Service微服务、异步任务、数据库、API/Page的Path，具体参考开发代码规范环节对不同层的落地规则如何保持一致，保证垂直边界清晰；</li>
<li>重用——领域间依赖、重用其他领域能力<strong>：</strong>域和域之间保持强依赖，对其他领域依赖的需求一定要在其他领域提诉求实现，反之自己的域也要承接其他所有域的依赖，以构建闭环的领域生命体；</li>
</ul>
</li>
<li><p>领域定义原则，回答下列问题(只要你能回答这3个问题，你就是个领域，至于要不要拆除独立定义，得看粒度)：</p>
<ul>
<li>领域职责（愿景）是什么？</li>
<li>领域的问题空间边界是什么？</li>
<li>领域核心实体是什么？</li>
</ul>
</li>
</ul>
<p><strong>拆分方法：</strong></p>
<p><img src="/images/%E6%88%91%E7%9A%84%E9%A2%86%E5%9F%9F%E8%A7%82-%E5%85%B3%E4%BA%8E%E9%A2%86%E5%9F%9F%E5%88%92%E5%88%86/out-20240128124309730.png" alt="img"></p>
<p>需要明确的是我们做的是业务建模工作，首先需要的就是全面了解业务，了解业务的方法有很多种，比如事件风暴，比如uml建模，比如阅读代码，甚至是请教领域专家，但是在做划分之前，一定要保证对业务的全面了解，并且对业务发展有足够的前瞻意识，以顶层视角来进行领域划分定义。下图只是展示了2种参考路径，有个明确共识，<strong>领域是基于业务认知结合现状拆聚出来的，最终团队达成一致。</strong>拆是为了保证摸清全部业务脉络，聚是为了寻找共性，进行抽象。最终满足上述原则和目标。</p>
<p><img src="/images/%E6%88%91%E7%9A%84%E9%A2%86%E5%9F%9F%E8%A7%82-%E5%85%B3%E4%BA%8E%E9%A2%86%E5%9F%9F%E5%88%92%E5%88%86/out-20240128124315874.png" alt="img"></p>
<p>【洞察业务】对于具体的业务，我们基于已有的了解上，可以通过白盒化的方式，完整的梳理业务的业务流，</p>
<p>【描述业务】我们可以用直播业务来说明下，下面的框图对直播业务进行完整描述：</p>
<p><img src="/images/%E6%88%91%E7%9A%84%E9%A2%86%E5%9F%9F%E8%A7%82-%E5%85%B3%E4%BA%8E%E9%A2%86%E5%9F%9F%E5%88%92%E5%88%86/out-20240128124342659.png" alt="img"></p>
<ol>
<li><p><strong>以上框图可以完整描述一级领域直播的全部业务</strong>。直播间是一级直播领域的核心实体，对于其他一级领域也是以直播间作为聚合根提供服务，直播间的实体包含主播信息和直播间信息。整个业务围绕直播间展开，以此为基础进行分发、消费、互动</p>
</li>
<li><p><strong>能够支撑业务发展</strong>，各框图其边界清晰，有自己明确的定位和业务目标，业务规则均可聚合在各框图，业务侧的动作均是在此流程上建立</p>
</li>
<li><p><strong>能够服务到全部生态角色，</strong>生态参与者(主播/公会)均有独立明确领域为其提供服务能力</p>
</li>
<li><p><strong>符合当前团队/业务规模，</strong>这些领域能否细化？答案是必然的，但是细化之后不可避免的带来资源的浪费(服务过多，负载较低)和维护成本的增加(单人维护的服务数过多)，得不偿失，因此我们认为以此粒度基本符合当下团队规模。</p>
</li>
</ol>
<p>【适配业务】对于这块，我们还是希望领域的划分与业务的发展目标保持一致，这里既包含团队分工，也包含业务目标。 我们会尝试以领域愿景(愿景本身可以随业务发展而迭代)串联业务和工程能力， 故以此为基础，进行领域划分，明确职责，<strong>团队达成一致</strong></p>
<p>我们尝试用Q3的需要占比已经需求跨领域的数量，来浅浅的示意我们这种领域划分的方式与实际业务的契合程度，仅做参考(不会是唯一衡量指标)</p>
<h3 id="怎么评价划分好坏"><a href="#怎么评价划分好坏" class="headerlink" title="怎么评价划分好坏"></a><strong>怎么评价划分好坏</strong></h3><p><img src="/images/%E6%88%91%E7%9A%84%E9%A2%86%E5%9F%9F%E8%A7%82-%E5%85%B3%E4%BA%8E%E9%A2%86%E5%9F%9F%E5%88%92%E5%88%86/image-20250422122050404-5295655.png" alt="image-20250422122050404"></p>
<p>关于指标的定义，回到划分的目的上，为了保持对业务的迭代的高效支撑。因此，可以从这个指标三角形的角度来权衡领域划分的目标和收益</p>
<ul>
<li>稳定性</li>
<li>研发效率</li>
<li>应变能力</li>
</ul>
<p>事实上，领域的划分是一个相对动态的过程，在这个过程中过，我们会持续用需求的闭环率、各领域的需求pd数、工程代码量、资源分布等维度去动态观察划分的合理性。</p>
<h3 id="拆了之后"><a href="#拆了之后" class="headerlink" title="拆了之后"></a><strong>拆了之后</strong></h3><p>领域化的起点是针对当前系统迭代效率&amp;协作风险和业务高速灵活发展之间的矛盾，提出的一种解决方案，但是领域化不仅仅是工程技术层面的问题，更多的是需要围绕业务领域出发，经过领域化分拆重塑脉络之后，也是希望技术同学能够在各自领域多一些业务知识的积累和沉淀，能够有自己的业务思考，从领域愿景出发，更好的用技术去赋能更多的可能性，助力业务起飞，而不单单是实现产品1/2/3功能的工具人。</p>
<p><img src="/images/%E6%88%91%E7%9A%84%E9%A2%86%E5%9F%9F%E8%A7%82-%E5%85%B3%E4%BA%8E%E9%A2%86%E5%9F%9F%E5%88%92%E5%88%86/resize,w_1656,m_lfit,limit_0.png" alt="9ff5612cadf163455c67467b538e7a6f"></p>
]]></content>
      <tags>
        <tag>领域划分</tag>
        <tag>业务建模</tag>
        <tag>架构思考</tag>
      </tags>
  </entry>
</search>
